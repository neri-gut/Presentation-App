{
  "version": 3,
  "sources": ["../../.pnpm/mutative@1.2.0/node_modules/mutative/src/interface.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/constant.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/internal.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/utils/proto.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/utils/draft.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/utils/copy.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/utils/mark.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/utils/deepFreeze.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/utils/forEach.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/utils/finalize.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/patch.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/unsafe.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/map.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/set.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/draft.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/draftify.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/current.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/makeCreator.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/create.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/apply.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/original.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/rawReturn.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/utils/marker.ts", "../../.pnpm/mutative@1.2.0/node_modules/mutative/src/utils/cast.ts", "../../.pnpm/use-mutative@1.3.0_@types+react@19.1.8_mutative@1.2.0_react@19.1.0/node_modules/use-mutative/dist/index.js"],
  "sourcesContent": ["import { dataTypes } from './constant';\n\nexport const enum DraftType {\n  Object,\n  Array,\n  Map,\n  Set,\n}\n\nexport const Operation = {\n  Remove: 'remove',\n  Replace: 'replace',\n  Add: 'add',\n} as const;\n\nexport type DataType = keyof typeof dataTypes;\n\nexport type PatchesOptions =\n  | boolean\n  | {\n      /**\n       * The default value is `true`. If it's `true`, the path will be an array, otherwise it is a string.\n       */\n      pathAsArray?: boolean;\n      /**\n       * The default value is `true`. If it's `true`, the array length will be included in the patches, otherwise no include array length.\n       */\n      arrayLengthAssignment?: boolean;\n    };\n\nexport interface Finalities {\n  draft: ((patches?: Patches, inversePatches?: Patches) => void)[];\n  revoke: (() => void)[];\n  handledSet: WeakSet<any>;\n}\n\nexport interface ProxyDraft<T = any> {\n  type: DraftType;\n  operated?: boolean;\n  finalized: boolean;\n  original: T;\n  copy: T | null;\n  proxy: T | null;\n  finalities: Finalities;\n  options: Options<any, any> & { updatedValues?: WeakMap<any, any> };\n  parent?: ProxyDraft | null;\n  key?: string | number | symbol;\n  setMap?: Map<any, ProxyDraft>;\n  assignedMap?: Map<any, boolean>;\n  callbacks?: ((patches?: Patches, inversePatches?: Patches) => void)[];\n}\n\nexport interface IPatch {\n  op: (typeof Operation)[keyof typeof Operation];\n  value?: any;\n}\n\nexport type Patch<P extends PatchesOptions = any> = P extends {\n  pathAsArray: false;\n}\n  ? IPatch & {\n      path: string;\n    }\n  : P extends true | object\n  ? IPatch & {\n      path: (string | number)[];\n    }\n  : IPatch & {\n      path: string | (string | number)[];\n    };\n\nexport type Patches<P extends PatchesOptions = any> = Patch<P>[];\n\nexport type Result<\n  T extends any,\n  O extends PatchesOptions,\n  F extends boolean\n> = O extends true | object\n  ? [F extends true ? Immutable<T> : T, Patches<O>, Patches<O>]\n  : F extends true\n  ? Immutable<T>\n  : T;\n\nexport type CreateResult<\n  T extends any,\n  O extends PatchesOptions,\n  F extends boolean,\n  R extends void | Promise<void> | T | Promise<T>\n> = R extends Promise<void> | Promise<T>\n  ? Promise<Result<T, O, F>>\n  : Result<T, O, F>;\n\ntype BaseMark = null | undefined | DataType;\ntype MarkWithCopy = BaseMark | (() => any);\n\nexport type Mark<O extends PatchesOptions, F extends boolean> = (\n  target: any,\n  types: typeof dataTypes\n) => O extends true | object\n  ? BaseMark\n  : F extends true\n  ? BaseMark\n  : MarkWithCopy;\n\nexport interface ApplyMutableOptions {\n  /**\n   * If it's `true`, the state will be mutated directly.\n   */\n  mutable?: boolean;\n}\n\nexport interface Options<O extends PatchesOptions, F extends boolean> {\n  /**\n   * In strict mode, Forbid accessing non-draftable values and forbid returning a non-draft value.\n   */\n  strict?: boolean;\n  /**\n   * Enable patch, and return the patches and inversePatches.\n   */\n  enablePatches?: O;\n  /**\n   * Enable autoFreeze, and return frozen state.\n   */\n  enableAutoFreeze?: F;\n  /**\n   * Set a mark to determine if the object is mutable or if an instance is an immutable.\n   * And it can also return a shallow copy function(AutoFreeze and Patches should both be disabled).\n   */\n  mark?: Mark<O, F>;\n}\n\nexport interface ExternalOptions<O extends PatchesOptions, F extends boolean> {\n  /**\n   * In strict mode, Forbid accessing non-draftable values and forbid returning a non-draft value.\n   */\n  strict?: boolean;\n  /**\n   * Enable patch, and return the patches and inversePatches.\n   */\n  enablePatches?: O;\n  /**\n   * Enable autoFreeze, and return frozen state.\n   */\n  enableAutoFreeze?: F;\n  /**\n   * Set a mark to determine if the object is mutable or if an instance is an immutable.\n   * And it can also return a shallow copy function(AutoFreeze and Patches should both be disabled).\n   */\n  mark?: Mark<O, F>[] | Mark<O, F>;\n}\n\n// Exclude `symbol`\ntype Primitive = string | number | bigint | boolean | null | undefined;\n\ntype ImmutableMap<K, V> = ReadonlyMap<Immutable<K>, Immutable<V>>;\ntype ImmutableSet<T> = ReadonlySet<Immutable<T>>;\ntype ImmutableObject<T> = { readonly [K in keyof T]: Immutable<T[K]> };\n\nexport type IfAvailable<T, Fallback = void> = true | false extends (\n  T extends never ? true : false\n)\n  ? Fallback\n  : keyof T extends never\n  ? Fallback\n  : T;\ntype WeakReferences =\n  | IfAvailable<WeakMap<any, any>>\n  | IfAvailable<WeakSet<any>>;\ntype AtomicObject = Function | Promise<any> | Date | RegExp;\n\nexport type Immutable<T> = T extends Primitive | AtomicObject\n  ? T\n  : T extends IfAvailable<ReadonlyMap<infer K, infer V>>\n  ? ImmutableMap<K, V>\n  : T extends IfAvailable<ReadonlySet<infer V>>\n  ? ImmutableSet<V>\n  : T extends WeakReferences\n  ? T\n  : T extends object\n  ? ImmutableObject<T>\n  : T;\n\ntype DraftedMap<K, V> = Map<K, Draft<V>>;\ntype DraftedSet<T> = Set<Draft<T>>;\ntype DraftedObject<T> = {\n  -readonly [K in keyof T]: Draft<T[K]>;\n};\n\nexport type Draft<T> = T extends Primitive | AtomicObject\n  ? T\n  : T extends IfAvailable<ReadonlyMap<infer K, infer V>>\n  ? DraftedMap<K, V>\n  : T extends IfAvailable<ReadonlySet<infer V>>\n  ? DraftedSet<V>\n  : T extends WeakReferences\n  ? T\n  : T extends object\n  ? DraftedObject<T>\n  : T;\n\nexport type ApplyOptions<F extends boolean> =\n  | Pick<\n      Options<boolean, F>,\n      Exclude<keyof Options<boolean, F>, 'enablePatches'>\n    >\n  | ApplyMutableOptions;\n\nexport type ApplyResult<\n  T extends object,\n  F extends boolean = false,\n  A extends ApplyOptions<F> = ApplyOptions<F>\n> = A extends { mutable: true } ? void : T;\n", "// Don't use `Symbol()` just for 3rd party access the draft\nexport const PROXY_DRAFT = Symbol.for('__MUTATIVE_PROXY_DRAFT__');\nexport const RAW_RETURN_SYMBOL = Symbol('__MUTATIVE_RAW_RETURN_SYMBOL__');\n\nexport const iteratorSymbol: typeof Symbol.iterator = Symbol.iterator;\n\nexport const dataTypes = {\n  mutable: 'mutable',\n  immutable: 'immutable',\n} as const;\n", "import { createDraft } from './draft';\n\nexport const internal = {} as {\n  createDraft: typeof createDraft;\n};\n", "export function has(target: object, key: PropertyKey) {\n  return target instanceof Map\n    ? target.has(key)\n    : Object.prototype.hasOwnProperty.call(target, key);\n}\n\nexport function getDescriptor(target: object, key: PropertyKey) {\n  if (key in target) {\n    let prototype = Reflect.getPrototypeOf(target);\n    while (prototype) {\n      const descriptor = Reflect.getOwnPropertyDescriptor(prototype, key);\n      if (descriptor) return descriptor;\n      prototype = Reflect.getPrototypeOf(prototype);\n    }\n  }\n  return;\n}\n\nexport function isBaseSetInstance(obj: any) {\n  return Object.getPrototypeOf(obj) === Set.prototype;\n}\n\nexport function isBaseMapInstance(obj: any) {\n  return Object.getPrototypeOf(obj) === Map.prototype;\n}\n", "import { DraftType, Mark, ProxyDraft } from '../interface';\nimport { dataTypes, PROXY_DRAFT } from '../constant';\nimport { has } from './proto';\n\nexport function latest<T = any>(proxyDraft: ProxyDraft): T {\n  return proxyDraft.copy ?? proxyDraft.original;\n}\n\n/**\n * Check if the value is a draft\n */\nexport function isDraft(target: any) {\n  return !!getProxyDraft(target);\n}\n\nexport function getProxyDraft<T extends any>(value: T): ProxyDraft | null {\n  if (typeof value !== 'object') return null;\n  return (value as { [PROXY_DRAFT]: any })?.[PROXY_DRAFT];\n}\n\nexport function getValue<T extends object>(value: T): T {\n  const proxyDraft = getProxyDraft(value);\n  return proxyDraft ? proxyDraft.copy ?? proxyDraft.original : value;\n}\n\n/**\n * Check if a value is draftable\n */\nexport function isDraftable(value: any, options?: { mark?: Mark<any, any> }) {\n  if (!value || typeof value !== 'object') return false;\n  let markResult: any;\n  return (\n    Object.getPrototypeOf(value) === Object.prototype ||\n    Array.isArray(value) ||\n    value instanceof Map ||\n    value instanceof Set ||\n    (!!options?.mark &&\n      ((markResult = options.mark(value, dataTypes)) === dataTypes.immutable ||\n        typeof markResult === 'function'))\n  );\n}\n\nexport function getPath(\n  target: ProxyDraft,\n  path: any[] = []\n): (string | number | object)[] | null {\n  if (Object.hasOwnProperty.call(target, 'key')) {\n    // check if the parent is a draft and the original value is not equal to the current value\n    const parentCopy = target.parent!.copy;\n    const proxyDraft = getProxyDraft(get(parentCopy, target.key!));\n    if (proxyDraft !== null && proxyDraft?.original !== target.original) {\n      return null;\n    }\n    const isSet = target.parent!.type === DraftType.Set;\n    const key = isSet\n      ? Array.from(target.parent!.setMap!.keys()).indexOf(target.key)\n      : target.key;\n    // check if the key is still in the next state parent\n    if (\n      !((isSet && parentCopy.size > (key as number)) || has(parentCopy, key!))\n    )\n      return null;\n    path.push(key);\n  }\n  if (target.parent) {\n    return getPath(target.parent, path);\n  }\n  // `target` is root draft.\n  path.reverse();\n  try {\n    // check if the path is valid\n    resolvePath(target.copy, path);\n  } catch (e) {\n    return null;\n  }\n  return path;\n}\n\nexport function getType(target: any) {\n  if (Array.isArray(target)) return DraftType.Array;\n  if (target instanceof Map) return DraftType.Map;\n  if (target instanceof Set) return DraftType.Set;\n  return DraftType.Object;\n}\n\nexport function get(target: any, key: PropertyKey) {\n  return getType(target) === DraftType.Map ? target.get(key) : target[key];\n}\n\nexport function set(target: any, key: PropertyKey, value: any) {\n  const type = getType(target);\n  if (type === DraftType.Map) {\n    target.set(key, value);\n  } else {\n    target[key] = value;\n  }\n}\n\nexport function peek(target: any, key: PropertyKey) {\n  const state = getProxyDraft(target);\n  const source = state ? latest(state) : target;\n  return source[key];\n}\n\nexport function isEqual(x: any, y: any) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nexport function revokeProxy(proxyDraft: ProxyDraft | null) {\n  if (!proxyDraft) return;\n  while (proxyDraft.finalities.revoke.length > 0) {\n    const revoke = proxyDraft.finalities.revoke.pop()!;\n    revoke();\n  }\n}\n\n// handle JSON Pointer path with spec https://www.rfc-editor.org/rfc/rfc6901\nexport function escapePath(path: string[], pathAsArray: boolean) {\n  return pathAsArray\n    ? path\n    : ['']\n        .concat(path)\n        .map((_item) => {\n          const item = `${_item}`;\n          if (item.indexOf('/') === -1 && item.indexOf('~') === -1) return item;\n          return item.replace(/~/g, '~0').replace(/\\//g, '~1');\n        })\n        .join('/');\n}\n\nexport function unescapePath(path: string | (string | number)[]) {\n  if (Array.isArray(path)) return path;\n  return path\n    .split('/')\n    .map((_item) => _item.replace(/~1/g, '/').replace(/~0/g, '~'))\n    .slice(1);\n}\n\nexport function resolvePath(base: any, path: (string | number)[]) {\n  for (let index = 0; index < path.length - 1; index += 1) {\n    const key = path[index];\n    // use `index` in Set draft\n    base = get(getType(base) === DraftType.Set ? Array.from(base) : base, key);\n    if (typeof base !== 'object') {\n      throw new Error(`Cannot resolve patch at '${path.join('/')}'.`);\n    }\n  }\n  return base;\n}\n", "import type { Options, ProxyDraft } from '../interface';\nimport { dataTypes } from '../constant';\nimport { getValue, isDraft, isDraftable } from './draft';\nimport { isBaseMapInstance, isBaseSetInstance } from './proto';\n\nfunction strictCopy(target: any) {\n  const copy = Object.create(Object.getPrototypeOf(target));\n  Reflect.ownKeys(target).forEach((key: any) => {\n    let desc = Reflect.getOwnPropertyDescriptor(target, key)!;\n    if (desc.enumerable && desc.configurable && desc.writable) {\n      copy[key] = target[key];\n      return;\n    }\n    // for freeze\n    if (!desc.writable) {\n      desc.writable = true;\n      desc.configurable = true;\n    }\n    if (desc.get || desc.set)\n      desc = {\n        configurable: true,\n        writable: true,\n        enumerable: desc.enumerable,\n        value: target[key],\n      };\n    Reflect.defineProperty(copy, key, desc);\n  });\n  return copy;\n}\n\nconst propIsEnum = Object.prototype.propertyIsEnumerable;\n\nexport function shallowCopy(original: any, options?: Options<any, any>) {\n  let markResult: any;\n  if (Array.isArray(original)) {\n    return Array.prototype.concat.call(original);\n  } else if (original instanceof Set) {\n    if (!isBaseSetInstance(original)) {\n      const SubClass = Object.getPrototypeOf(original).constructor;\n      return new SubClass(original.values());\n    }\n    return Set.prototype.difference\n      ? Set.prototype.difference.call(original, new Set())\n      : new Set(original.values());\n  } else if (original instanceof Map) {\n    if (!isBaseMapInstance(original)) {\n      const SubClass = Object.getPrototypeOf(original).constructor;\n      return new SubClass(original);\n    }\n    return new Map(original);\n  } else if (\n    options?.mark &&\n    ((markResult = options.mark(original, dataTypes)),\n    markResult !== undefined) &&\n    markResult !== dataTypes.mutable\n  ) {\n    if (markResult === dataTypes.immutable) {\n      return strictCopy(original);\n    } else if (typeof markResult === 'function') {\n      if (__DEV__ && (options.enablePatches || options.enableAutoFreeze)) {\n        throw new Error(\n          `You can't use mark and patches or auto freeze together.`\n        );\n      }\n      return markResult();\n    }\n    throw new Error(`Unsupported mark result: ${markResult}`);\n  } else if (\n    typeof original === 'object' &&\n    Object.getPrototypeOf(original) === Object.prototype\n  ) {\n    // For best performance with shallow copies,\n    // don't use `Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));` by default.\n    const copy: Record<string | symbol, any> = {};\n    Object.keys(original).forEach((key) => {\n      copy[key] = original[key];\n    });\n    Object.getOwnPropertySymbols(original).forEach((key) => {\n      if (propIsEnum.call(original, key)) {\n        copy[key] = original[key];\n      }\n    });\n    return copy;\n  } else {\n    throw new Error(\n      `Please check mark() to ensure that it is a stable marker draftable function.`\n    );\n  }\n}\n\nexport function ensureShallowCopy(target: ProxyDraft) {\n  if (target.copy) return;\n  target.copy = shallowCopy(target.original, target.options)!;\n}\n\nfunction deepClone<T>(target: T): T;\nfunction deepClone(target: any) {\n  if (!isDraftable(target)) return getValue(target);\n  if (Array.isArray(target)) return target.map(deepClone);\n  if (target instanceof Map) {\n    const iterable = Array.from(target.entries()).map(([k, v]) => [\n      k,\n      deepClone(v),\n    ]) as Iterable<readonly [any, any]>;\n    if (!isBaseMapInstance(target)) {\n      const SubClass = Object.getPrototypeOf(target).constructor;\n      return new SubClass(iterable);\n    }\n    return new Map(iterable);\n  }\n  if (target instanceof Set) {\n    const iterable = Array.from(target).map(deepClone);\n    if (!isBaseSetInstance(target)) {\n      const SubClass = Object.getPrototypeOf(target).constructor;\n      return new SubClass(iterable);\n    }\n    return new Set(iterable);\n  }\n  const copy = Object.create(Object.getPrototypeOf(target));\n  for (const key in target) copy[key] = deepClone(target[key]);\n  return copy;\n}\n\nexport function cloneIfNeeded<T>(target: T): T {\n  return isDraft(target) ? deepClone(target) : target;\n}\n\nexport { deepClone };\n", "import { ProxyDraft } from '../interface';\n\nexport function markChanged(proxyDraft: ProxyDraft) {\n  proxyDraft.assignedMap = proxyDraft.assignedMap ?? new Map();\n  if (!proxyDraft.operated) {\n    proxyDraft.operated = true;\n    if (proxyDraft.parent) {\n      markChanged(proxyDraft.parent);\n    }\n  }\n}\n", "import { DraftType } from '../interface';\nimport { getType, isDraft } from './draft';\n\nfunction throwFrozenError() {\n  throw new Error('Cannot modify frozen object');\n}\n\nfunction isFreezable(value: any) {\n  return (\n    __DEV__ || (value && typeof value === 'object' && !Object.isFrozen(value))\n  );\n}\n\nexport function deepFreeze(\n  target: any,\n  subKey?: any,\n  updatedValues?: WeakMap<any, any>,\n  stack?: any[],\n  keys?: any[]\n) {\n  if (__DEV__) {\n    updatedValues = updatedValues ?? new WeakMap();\n    stack = stack ?? [];\n    keys = keys ?? [];\n    const value = updatedValues.has(target)\n      ? updatedValues.get(target)\n      : target;\n    if (stack.length > 0) {\n      const index = stack.indexOf(value);\n      if (value && typeof value === 'object' && index !== -1) {\n        if (stack[0] === value) {\n          throw new Error(`Forbids circular reference`);\n        }\n        throw new Error(\n          `Forbids circular reference: ~/${keys\n            .slice(0, index)\n            .map((key, index) => {\n              if (typeof key === 'symbol') return `[${key.toString()}]`;\n              const parent = stack![index];\n              if (\n                typeof key === 'object' &&\n                (parent instanceof Map || parent instanceof Set)\n              )\n                return Array.from(parent.keys()).indexOf(key);\n              return key;\n            })\n            .join('/')}`\n        );\n      }\n      stack.push(value);\n      keys.push(subKey);\n    } else {\n      stack.push(value);\n    }\n  }\n  if (Object.isFrozen(target) || isDraft(target)) {\n    if (__DEV__) {\n      stack!.pop();\n      keys!.pop();\n    }\n    return;\n  }\n  const type = getType(target);\n  switch (type) {\n    case DraftType.Map:\n      for (const [key, value] of target) {\n        if (isFreezable(key)) deepFreeze(key, key, updatedValues, stack, keys);\n        if (isFreezable(value))\n          deepFreeze(value, key, updatedValues, stack, keys);\n      }\n      target.set = target.clear = target.delete = throwFrozenError;\n      break;\n    case DraftType.Set:\n      for (const value of target) {\n        if (isFreezable(value))\n          deepFreeze(value, value, updatedValues, stack, keys);\n      }\n      target.add = target.clear = target.delete = throwFrozenError;\n      break;\n    case DraftType.Array:\n      Object.freeze(target);\n      let index = 0;\n      for (const value of target) {\n        if (isFreezable(value))\n          deepFreeze(value, index, updatedValues, stack, keys);\n        index += 1;\n      }\n      break;\n    default:\n      Object.freeze(target);\n      // ignore non-enumerable or symbol properties\n      Object.keys(target).forEach((name) => {\n        const value = target[name];\n        if (isFreezable(value))\n          deepFreeze(value, name, updatedValues, stack, keys);\n      });\n  }\n  if (__DEV__) {\n    stack!.pop();\n    keys!.pop();\n  }\n}\n", "import { DraftType } from '../interface';\nimport { getType } from './draft';\n\nexport function forEach<T extends object>(\n  target: T,\n  iter: (key: string | number | symbol, value: any, source: T) => void\n) {\n  const type = getType(target);\n  if (type === DraftType.Object) {\n    Reflect.ownKeys(target).forEach((key) => {\n      iter(key, (target as any)[key], target);\n    });\n  } else if (type === DraftType.Array) {\n    let index = 0;\n    for (const entry of target as any[]) {\n      iter(index, entry, target);\n      index += 1;\n    }\n  } else {\n    (target as Map<any, any> | Set<any>).forEach((entry: any, index: any) =>\n      iter(index, entry, target)\n    );\n  }\n}\n", "import { DraftType, Patches, ProxyDraft } from '../interface';\nimport { ensureShallowCopy } from './copy';\nimport {\n  get,\n  getPath,\n  getProxyDraft,\n  getValue,\n  isDraft,\n  isDraftable,\n  isEqual,\n  set,\n} from './draft';\nimport { forEach } from './forEach';\n\nexport function handleValue(\n  target: any,\n  handledSet: WeakSet<any>,\n  options?: ProxyDraft['options']\n) {\n  if (\n    isDraft(target) ||\n    !isDraftable(target, options) ||\n    handledSet.has(target) ||\n    Object.isFrozen(target)\n  )\n    return;\n  const isSet = target instanceof Set;\n  const setMap: Map<any, any> | undefined = isSet ? new Map() : undefined;\n  handledSet.add(target);\n  forEach(target, (key, value) => {\n    if (isDraft(value)) {\n      const proxyDraft = getProxyDraft(value)!;\n      ensureShallowCopy(proxyDraft);\n      // A draft where a child node has been changed, or assigned a value\n      const updatedValue =\n        proxyDraft.assignedMap?.size || proxyDraft.operated\n          ? proxyDraft.copy\n          : proxyDraft.original;\n      // final update value\n      set(isSet ? setMap! : target, key, updatedValue);\n    } else {\n      handleValue(value, handledSet, options);\n    }\n  });\n  if (setMap) {\n    const set = target as Set<any>;\n    const values = Array.from(set);\n    set.clear();\n    values.forEach((value) => {\n      set.add(setMap!.has(value) ? setMap!.get(value) : value);\n    });\n  }\n}\n\nexport function finalizeAssigned(proxyDraft: ProxyDraft, key: PropertyKey) {\n  // handle the draftable assigned valuesï¼Œ and the value is not a draft\n  const copy =\n    proxyDraft.type === DraftType.Set ? proxyDraft.setMap : proxyDraft.copy;\n  if (\n    proxyDraft.finalities.revoke.length > 1 &&\n    proxyDraft.assignedMap!.get(key) &&\n    copy\n  ) {\n    handleValue(\n      get(copy, key),\n      proxyDraft.finalities.handledSet,\n      proxyDraft.options\n    );\n  }\n}\n\nexport type GeneratePatches = (\n  proxyState: ProxyDraft,\n  basePath: any[],\n  patches: Patches,\n  inversePatches: Patches\n) => void;\n\nexport function finalizeSetValue(target: ProxyDraft) {\n  if (target.type === DraftType.Set && target.copy) {\n    target.copy.clear();\n    target.setMap!.forEach((value) => {\n      target.copy!.add(getValue(value));\n    });\n  }\n}\n\nexport function finalizePatches(\n  target: ProxyDraft,\n  generatePatches: GeneratePatches,\n  patches?: Patches,\n  inversePatches?: Patches\n) {\n  const shouldFinalize =\n    target.operated &&\n    target.assignedMap &&\n    target.assignedMap.size > 0 &&\n    !target.finalized;\n  if (shouldFinalize) {\n    if (patches && inversePatches) {\n      const basePath = getPath(target);\n      if (basePath) {\n        generatePatches(target, basePath, patches, inversePatches);\n      }\n    }\n    target.finalized = true;\n  }\n}\n\nexport function markFinalization(\n  target: ProxyDraft,\n  key: any,\n  value: any,\n  generatePatches: GeneratePatches\n) {\n  const proxyDraft = getProxyDraft(value);\n  if (proxyDraft) {\n    // !case: assign the draft value\n    if (!proxyDraft.callbacks) {\n      proxyDraft.callbacks = [];\n    }\n    proxyDraft.callbacks.push((patches, inversePatches) => {\n      const copy = target.type === DraftType.Set ? target.setMap : target.copy;\n      if (isEqual(get(copy, key), value)) {\n        let updatedValue = proxyDraft.original;\n        if (proxyDraft.copy) {\n          updatedValue = proxyDraft.copy;\n        }\n        finalizeSetValue(target);\n        finalizePatches(target, generatePatches, patches, inversePatches);\n        if (__DEV__ && target.options.enableAutoFreeze) {\n          target.options.updatedValues =\n            target.options.updatedValues ?? new WeakMap();\n          target.options.updatedValues.set(updatedValue, proxyDraft.original);\n        }\n        // final update value\n        set(copy, key, updatedValue);\n      }\n    });\n    if (target.options.enableAutoFreeze) {\n      // !case: assign the draft value in cross draft tree\n      if (proxyDraft.finalities !== target.finalities) {\n        target.options.enableAutoFreeze = false;\n      }\n    }\n  }\n  if (isDraftable(value, target.options)) {\n    // !case: assign the non-draft value\n    target.finalities.draft.push(() => {\n      const copy = target.type === DraftType.Set ? target.setMap : target.copy;\n      if (isEqual(get(copy, key), value)) {\n        finalizeAssigned(target, key);\n      }\n    });\n  }\n}\n", "import { DraftType, Operation, Patches, ProxyDraft } from './interface';\nimport { cloneIfNeeded, escapePath, get, has, isEqual } from './utils';\n\nfunction generateArrayPatches(\n  proxyState: ProxyDraft<Array<any>>,\n  basePath: any[],\n  patches: Patches,\n  inversePatches: Patches,\n  pathAsArray: boolean\n) {\n  let { original, assignedMap, options } = proxyState;\n  let copy = proxyState.copy!;\n  if (copy.length < original.length) {\n    [original, copy] = [copy, original];\n    [patches, inversePatches] = [inversePatches, patches];\n  }\n  for (let index = 0; index < original.length; index += 1) {\n    if (assignedMap!.get(index.toString()) && copy[index] !== original[index]) {\n      const _path = basePath.concat([index]);\n      const path = escapePath(_path, pathAsArray);\n      patches.push({\n        op: Operation.Replace,\n        path,\n        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n        value: cloneIfNeeded(copy[index]),\n      });\n      inversePatches.push({\n        op: Operation.Replace,\n        path,\n        // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n        value: cloneIfNeeded(original[index]),\n      });\n    }\n  }\n  for (let index = original.length; index < copy.length; index += 1) {\n    const _path = basePath.concat([index]);\n    const path = escapePath(_path, pathAsArray);\n    patches.push({\n      op: Operation.Add,\n      path,\n      // If it is a draft, it needs to be deep cloned, and it may also be non-draft.\n      value: cloneIfNeeded(copy[index]),\n    });\n  }\n  if (original.length < copy.length) {\n    // https://www.rfc-editor.org/rfc/rfc6902#appendix-A.4\n    // For performance, here we only generate an operation that replaces the length of the array,\n    // which is inconsistent with JSON Patch specification\n    const { arrayLengthAssignment = true } = options.enablePatches;\n    if (arrayLengthAssignment) {\n      const _path = basePath.concat(['length']);\n      const path = escapePath(_path, pathAsArray);\n      inversePatches.push({\n        op: Operation.Replace,\n        path,\n        value: original.length,\n      });\n    } else {\n      for (let index = copy.length; original.length < index; index -= 1) {\n        const _path = basePath.concat([index - 1]);\n        const path = escapePath(_path, pathAsArray);\n        inversePatches.push({\n          op: Operation.Remove,\n          path,\n        });\n      }\n    }\n  }\n}\n\nfunction generatePatchesFromAssigned(\n  { original, copy, assignedMap }: ProxyDraft<Record<string, any>>,\n  basePath: any[],\n  patches: Patches,\n  inversePatches: Patches,\n  pathAsArray: boolean\n) {\n  assignedMap!.forEach((assignedValue, key) => {\n    const originalValue = get(original, key);\n    const value = cloneIfNeeded(get(copy, key));\n    const op = !assignedValue\n      ? Operation.Remove\n      : has(original, key)\n      ? Operation.Replace\n      : Operation.Add;\n    if (isEqual(originalValue, value) && op === Operation.Replace) return;\n    const _path = basePath.concat(key);\n    const path = escapePath(_path, pathAsArray);\n    patches.push(op === Operation.Remove ? { op, path } : { op, path, value });\n    inversePatches.push(\n      op === Operation.Add\n        ? { op: Operation.Remove, path }\n        : op === Operation.Remove\n        ? { op: Operation.Add, path, value: originalValue }\n        : { op: Operation.Replace, path, value: originalValue }\n    );\n  });\n}\n\nfunction generateSetPatches(\n  { original, copy }: ProxyDraft<Set<any>>,\n  basePath: any[],\n  patches: Patches,\n  inversePatches: Patches,\n  pathAsArray: boolean\n) {\n  let index = 0;\n  original.forEach((value: any) => {\n    if (!copy!.has(value)) {\n      const _path = basePath.concat([index]);\n      const path = escapePath(_path, pathAsArray);\n      patches.push({\n        op: Operation.Remove,\n        path,\n        value,\n      });\n      inversePatches.unshift({\n        op: Operation.Add,\n        path,\n        value,\n      });\n    }\n    index += 1;\n  });\n  index = 0;\n  copy!.forEach((value: any) => {\n    if (!original.has(value)) {\n      const _path = basePath.concat([index]);\n      const path = escapePath(_path, pathAsArray);\n      patches.push({\n        op: Operation.Add,\n        path,\n        value,\n      });\n      inversePatches.unshift({\n        op: Operation.Remove,\n        path,\n        value,\n      });\n    }\n    index += 1;\n  });\n}\n\nexport function generatePatches(\n  proxyState: ProxyDraft,\n  basePath: any[],\n  patches: Patches,\n  inversePatches: Patches\n) {\n  const { pathAsArray = true } = proxyState.options.enablePatches;\n  switch (proxyState.type) {\n    case DraftType.Object:\n    case DraftType.Map:\n      return generatePatchesFromAssigned(\n        proxyState,\n        basePath,\n        patches,\n        inversePatches,\n        pathAsArray\n      );\n    case DraftType.Array:\n      return generateArrayPatches(\n        proxyState,\n        basePath,\n        patches,\n        inversePatches,\n        pathAsArray\n      );\n    case DraftType.Set:\n      return generateSetPatches(\n        proxyState,\n        basePath,\n        patches,\n        inversePatches,\n        pathAsArray\n      );\n  }\n}\n", "import { Options } from './interface';\nimport { isDraftable } from './utils';\n\nlet readable = false;\n\nexport const checkReadable = (\n  value: any,\n  options: Options<any, any>,\n  ignoreCheckDraftable = false\n) => {\n  if (\n    typeof value === 'object' &&\n    value !== null &&\n    (!isDraftable(value, options) || ignoreCheckDraftable) &&\n    !readable\n  ) {\n    throw new Error(\n      `Strict mode: Mutable data cannot be accessed directly, please use 'unsafe(callback)' wrap.`\n    );\n  }\n};\n\n/**\n * `unsafe(callback)` to access mutable data directly in strict mode.\n *\n * ## Example\n *\n * ```ts\n * import { create, unsafe } from '../index';\n *\n * class Foobar {\n *   bar = 1;\n * }\n *\n * const baseState = { foobar: new Foobar() };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *    unsafe(() => {\n *      draft.foobar.bar = 2;\n *    });\n *   },\n *   {\n *     strict: true,\n *   }\n * );\n *\n * expect(state).toBe(baseState);\n * expect(state.foobar).toBe(baseState.foobar);\n * expect(state.foobar.bar).toBe(2);\n * ```\n */\nexport function unsafe<T>(callback: () => T): T {\n  readable = true;\n  let result: T;\n  try {\n    result = callback();\n  } finally {\n    readable = false;\n  }\n  return result;\n}\n", "import { dataTypes, iteratorSymbol } from './constant';\nimport { internal } from './internal';\nimport { generatePatches } from './patch';\nimport { checkReadable } from './unsafe';\nimport {\n  ensureShallowCopy,\n  getProxyDraft,\n  isDraftable,\n  isEqual,\n  latest,\n  markChanged,\n  markFinalization,\n} from './utils';\n\nexport const mapHandler = {\n  get size() {\n    const current: Map<any, any> = latest(getProxyDraft(this)!);\n    return current.size;\n  },\n  has(key: any): boolean {\n    return latest(getProxyDraft(this)!).has(key);\n  },\n  set(key: any, value: any) {\n    const target = getProxyDraft(this)!;\n    const source = latest(target);\n    if (!source.has(key) || !isEqual(source.get(key), value)) {\n      ensureShallowCopy(target);\n      markChanged(target);\n      target.assignedMap!.set(key, true);\n      target.copy.set(key, value);\n      markFinalization(target, key, value, generatePatches);\n    }\n    return this;\n  },\n  delete(key: any): boolean {\n    if (!this.has(key)) {\n      return false;\n    }\n    const target = getProxyDraft(this)!;\n    ensureShallowCopy(target);\n    markChanged(target);\n    if (target.original.has(key)) {\n      target.assignedMap!.set(key, false);\n    } else {\n      target.assignedMap!.delete(key);\n    }\n    target.copy.delete(key);\n    return true;\n  },\n  clear() {\n    const target = getProxyDraft(this)!;\n    if (!this.size) return;\n    ensureShallowCopy(target);\n    markChanged(target);\n    target.assignedMap = new Map();\n    for (const [key] of target.original) {\n      target.assignedMap.set(key, false);\n    }\n    target.copy!.clear();\n  },\n  forEach(callback: (value: any, key: any, self: any) => void, thisArg?: any) {\n    const target = getProxyDraft(this)!;\n    latest(target).forEach((_value: any, _key: any) => {\n      callback.call(thisArg, this.get(_key), _key, this);\n    });\n  },\n  get(key: any): any {\n    const target = getProxyDraft(this)!;\n    const value = latest(target).get(key);\n    const mutable =\n      target.options.mark?.(value, dataTypes) === dataTypes.mutable;\n    if (target.options.strict) {\n      checkReadable(value, target.options, mutable);\n    }\n    if (mutable) {\n      return value;\n    }\n    if (target.finalized || !isDraftable(value, target.options)) {\n      return value;\n    }\n    // drafted or reassigned\n    if (value !== target.original.get(key)) {\n      return value;\n    }\n    const draft = internal.createDraft({\n      original: value,\n      parentDraft: target,\n      key,\n      finalities: target.finalities,\n      options: target.options,\n    });\n    ensureShallowCopy(target);\n    target.copy.set(key, draft);\n    return draft;\n  },\n  keys(): IterableIterator<any> {\n    return latest(getProxyDraft(this)!).keys();\n  },\n  values(): IterableIterator<any> {\n    const iterator = this.keys();\n    return {\n      [iteratorSymbol]: () => this.values(),\n      next: () => {\n        const result = iterator.next();\n        if (result.done) return result;\n        const value = this.get(result.value);\n        return {\n          done: false,\n          value,\n        };\n      },\n    } as any;\n  },\n  entries(): IterableIterator<[any, any]> {\n    const iterator = this.keys();\n    return {\n      [iteratorSymbol]: () => this.entries(),\n      next: () => {\n        const result = iterator.next();\n        if (result.done) return result;\n        const value = this.get(result.value);\n        return {\n          done: false,\n          value: [result.value, value],\n        };\n      },\n    } as any;\n  },\n  [iteratorSymbol]() {\n    return this.entries();\n  },\n};\n\nexport const mapHandlerKeys = Reflect.ownKeys(mapHandler);\n", "import { ProxyDraft } from './interface';\nimport { dataTypes, iteratorSymbol } from './constant';\nimport { internal } from './internal';\nimport {\n  ensureShallowCopy,\n  getProxyDraft,\n  isDraftable,\n  markChanged,\n  markFinalization,\n} from './utils';\nimport { checkReadable } from './unsafe';\nimport { generatePatches } from './patch';\n\nconst getNextIterator =\n  (\n    target: ProxyDraft<any>,\n    iterator: IterableIterator<any>,\n    { isValuesIterator }: { isValuesIterator: boolean }\n  ) =>\n  () => {\n    const result = iterator.next();\n    if (result.done) return result;\n    const key = result.value as any;\n    let value = target.setMap!.get(key);\n    const currentDraft = getProxyDraft(value);\n    const mutable =\n      target.options.mark?.(value, dataTypes) === dataTypes.mutable;\n    if (target.options.strict) {\n      checkReadable(key, target.options, mutable);\n    }\n    if (\n      !mutable &&\n      !currentDraft &&\n      isDraftable(key, target.options) &&\n      !target.finalized &&\n      target.original!.has(key)\n    ) {\n      // draft a draftable original set item\n      const proxy = internal.createDraft({\n        original: key,\n        parentDraft: target,\n        key,\n        finalities: target.finalities,\n        options: target.options,\n      });\n      target.setMap!.set(key, proxy);\n      value = proxy;\n    } else if (currentDraft) {\n      // drafted\n      value = currentDraft.proxy;\n    }\n    return {\n      done: false,\n      value: isValuesIterator ? value : [value, value],\n    };\n  };\n\nexport const setHandler = {\n  get size() {\n    const target: ProxyDraft<any> = getProxyDraft(this)!;\n    return target.setMap!.size;\n  },\n  has(value: any) {\n    const target = getProxyDraft(this)!;\n    // reassigned or non-draftable values\n    if (target.setMap!.has(value)) return true;\n    ensureShallowCopy(target);\n    const valueProxyDraft = getProxyDraft(value)!;\n    // drafted\n    if (valueProxyDraft && target.setMap!.has(valueProxyDraft.original))\n      return true;\n    return false;\n  },\n  add(value: any) {\n    const target = getProxyDraft(this)!;\n    if (!this.has(value)) {\n      ensureShallowCopy(target);\n      markChanged(target);\n      target.assignedMap!.set(value, true);\n      target.setMap!.set(value, value);\n      markFinalization(target, value, value, generatePatches);\n    }\n    return this;\n  },\n  delete(value: any): boolean {\n    if (!this.has(value)) {\n      return false;\n    }\n    const target = getProxyDraft(this)!;\n    ensureShallowCopy(target);\n    markChanged(target);\n    const valueProxyDraft = getProxyDraft(value)!;\n    if (valueProxyDraft && target.setMap!.has(valueProxyDraft.original)) {\n      // delete drafted\n      target.assignedMap!.set(valueProxyDraft.original, false);\n      return target.setMap!.delete(valueProxyDraft.original);\n    }\n    if (!valueProxyDraft && target.setMap!.has(value)) {\n      // non-draftable values\n      target.assignedMap!.set(value, false);\n    } else {\n      // reassigned\n      target.assignedMap!.delete(value);\n    }\n    // delete reassigned or non-draftable values\n    return target.setMap!.delete(value);\n  },\n  clear() {\n    if (!this.size) return;\n    const target = getProxyDraft(this)!;\n    ensureShallowCopy(target);\n    markChanged(target);\n    for (const value of target.original) {\n      target.assignedMap!.set(value, false);\n    }\n    target.setMap!.clear();\n  },\n  values(): IterableIterator<any> {\n    const target = getProxyDraft(this)!;\n    ensureShallowCopy(target);\n    const iterator = target.setMap!.keys();\n    return {\n      [Symbol.iterator]: () => this.values(),\n      next: getNextIterator(target, iterator, { isValuesIterator: true }),\n    };\n  },\n  entries(): IterableIterator<[any, any]> {\n    const target = getProxyDraft(this)!;\n    ensureShallowCopy(target);\n    const iterator = target.setMap!.keys();\n    return {\n      [Symbol.iterator]: () => this.entries(),\n      next: getNextIterator(target, iterator, {\n        isValuesIterator: false,\n      }) as () => IteratorReturnResult<any>,\n    };\n  },\n  keys(): IterableIterator<any> {\n    return this.values();\n  },\n  [iteratorSymbol]() {\n    return this.values();\n  },\n  forEach(callback: any, thisArg?: any) {\n    const iterator = this.values();\n    let result = iterator.next();\n    while (!result.done) {\n      callback.call(thisArg, result.value, result.value, this);\n      result = iterator.next();\n    }\n  },\n};\n\nif (Set.prototype.difference) {\n  // for compatibility with new Set methods\n  // https://github.com/tc39/proposal-set-methods\n  // And `https://github.com/tc39/proposal-set-methods/blob/main/details.md#symbolspecies` has some details about the `@@species` symbol.\n  // So we can't use SubSet instance constructor to get the constructor of the SubSet instance.\n  Object.assign(setHandler, {\n    intersection(this: Set<any>, other: ReadonlySetLike<any>): Set<any> {\n      return Set.prototype.intersection.call(new Set(this.values()), other);\n    },\n    union(this: Set<any>, other: ReadonlySetLike<any>): Set<any> {\n      return Set.prototype.union.call(new Set(this.values()), other);\n    },\n    difference(this: Set<any>, other: ReadonlySetLike<any>): Set<any> {\n      return Set.prototype.difference.call(new Set(this.values()), other);\n    },\n    symmetricDifference(this: Set<any>, other: ReadonlySetLike<any>): Set<any> {\n      return Set.prototype.symmetricDifference.call(\n        new Set(this.values()),\n        other\n      );\n    },\n    isSubsetOf(this: Set<any>, other: ReadonlySetLike<any>): boolean {\n      return Set.prototype.isSubsetOf.call(new Set(this.values()), other);\n    },\n    isSupersetOf(this: Set<any>, other: ReadonlySetLike<any>): boolean {\n      return Set.prototype.isSupersetOf.call(new Set(this.values()), other);\n    },\n    isDisjointFrom(this: Set<any>, other: ReadonlySetLike<any>): boolean {\n      return Set.prototype.isDisjointFrom.call(new Set(this.values()), other);\n    },\n  });\n}\n\nexport const setHandlerKeys = Reflect.ownKeys(setHandler);\n", "import {\n  DraftType,\n  Finalities,\n  Patches,\n  ProxyDraft,\n  Options,\n  Operation,\n} from './interface';\nimport { dataTypes, PROXY_DRAFT } from './constant';\nimport { mapHandler, mapHandlerKeys } from './map';\nimport { setHandler, setHandlerKeys } from './set';\nimport { internal } from './internal';\nimport {\n  deepFreeze,\n  ensureShallowCopy,\n  getDescriptor,\n  getProxyDraft,\n  getType,\n  getValue,\n  has,\n  isEqual,\n  isDraftable,\n  latest,\n  markChanged,\n  peek,\n  get,\n  set,\n  revokeProxy,\n  finalizeSetValue,\n  markFinalization,\n  finalizePatches,\n} from './utils';\nimport { checkReadable } from './unsafe';\nimport { generatePatches } from './patch';\n\nconst draftsCache = new WeakSet<object>();\n\nconst proxyHandler: ProxyHandler<ProxyDraft> = {\n  get(target: ProxyDraft, key: string | number | symbol, receiver: any) {\n    const copy = target.copy?.[key];\n    // Improve draft reading performance by caching the draft copy.\n    if (copy && draftsCache.has(copy)) {\n      return copy;\n    }\n    if (key === PROXY_DRAFT) return target;\n    let markResult: any;\n    if (target.options.mark) {\n      // handle `Uncaught TypeError: Method get Map.prototype.size called on incompatible receiver #<Map>`\n      // or `Uncaught TypeError: Method get Set.prototype.size called on incompatible receiver #<Set>`\n      const value =\n        key === 'size' &&\n        (target.original instanceof Map || target.original instanceof Set)\n          ? Reflect.get(target.original, key)\n          : Reflect.get(target.original, key, receiver);\n      markResult = target.options.mark(value, dataTypes);\n      if (markResult === dataTypes.mutable) {\n        if (target.options.strict) {\n          checkReadable(value, target.options, true);\n        }\n        return value;\n      }\n    }\n    const source = latest(target);\n\n    if (source instanceof Map && mapHandlerKeys.includes(key as any)) {\n      if (key === 'size') {\n        return Object.getOwnPropertyDescriptor(mapHandler, 'size')!.get!.call(\n          target.proxy\n        );\n      }\n      const handle = mapHandler[key as keyof typeof mapHandler] as Function;\n      if (handle) {\n        return handle.bind(target.proxy);\n      }\n    }\n\n    if (source instanceof Set && setHandlerKeys.includes(key as any)) {\n      if (key === 'size') {\n        return Object.getOwnPropertyDescriptor(setHandler, 'size')!.get!.call(\n          target.proxy\n        );\n      }\n      const handle = setHandler[key as keyof typeof setHandler] as Function;\n      if (handle) {\n        return handle.bind(target.proxy);\n      }\n    }\n\n    if (!has(source, key)) {\n      const desc = getDescriptor(source, key);\n      return desc\n        ? `value` in desc\n          ? desc.value\n          : // !case: support for getter\n            desc.get?.call(target.proxy)\n        : undefined;\n    }\n    const value = source[key];\n    if (target.options.strict) {\n      checkReadable(value, target.options);\n    }\n    if (target.finalized || !isDraftable(value, target.options)) {\n      return value;\n    }\n    // Ensure that the assigned values are not drafted\n    if (value === peek(target.original, key)) {\n      ensureShallowCopy(target);\n      target.copy![key] = createDraft({\n        original: target.original[key],\n        parentDraft: target,\n        key: target.type === DraftType.Array ? Number(key) : key,\n        finalities: target.finalities,\n        options: target.options,\n      });\n      // !case: support for custom shallow copy function\n      if (typeof markResult === 'function') {\n        const subProxyDraft = getProxyDraft(target.copy![key])!;\n        ensureShallowCopy(subProxyDraft);\n        // Trigger a custom shallow copy to update to a new copy\n        markChanged(subProxyDraft);\n        return subProxyDraft.copy;\n      }\n      return target.copy![key];\n    }\n    return value;\n  },\n  set(target: ProxyDraft, key: string | number | symbol, value: any) {\n    if (target.type === DraftType.Set || target.type === DraftType.Map) {\n      throw new Error(\n        `Map/Set draft does not support any property assignment.`\n      );\n    }\n    let _key: number;\n    if (\n      target.type === DraftType.Array &&\n      key !== 'length' &&\n      !(\n        Number.isInteger((_key = Number(key))) &&\n        _key >= 0 &&\n        (key === 0 || _key === 0 || String(_key) === String(key))\n      )\n    ) {\n      throw new Error(\n        `Only supports setting array indices and the 'length' property.`\n      );\n    }\n    const desc = getDescriptor(latest(target), key);\n    if (desc?.set) {\n      // !case: cover the case of setter\n      desc.set.call(target.proxy, value);\n      return true;\n    }\n    const current = peek(latest(target), key);\n    const currentProxyDraft = getProxyDraft(current);\n    if (currentProxyDraft && isEqual(currentProxyDraft.original, value)) {\n      // !case: ignore the case of assigning the original draftable value to a draft\n      target.copy![key] = value;\n      target.assignedMap = target.assignedMap ?? new Map();\n      target.assignedMap.set(key, false);\n      return true;\n    }\n    // !case: handle new props with value 'undefined'\n    if (\n      isEqual(value, current) &&\n      (value !== undefined || has(target.original, key))\n    )\n      return true;\n    ensureShallowCopy(target);\n    markChanged(target);\n    if (has(target.original, key) && isEqual(value, target.original[key])) {\n      // !case: handle the case of assigning the original non-draftable value to a draft\n      target.assignedMap!.delete(key);\n    } else {\n      target.assignedMap!.set(key, true);\n    }\n    target.copy![key] = value;\n    markFinalization(target, key, value, generatePatches);\n    return true;\n  },\n  has(target: ProxyDraft, key: string | symbol) {\n    return key in latest(target);\n  },\n  ownKeys(target: ProxyDraft) {\n    return Reflect.ownKeys(latest(target));\n  },\n  getOwnPropertyDescriptor(target: ProxyDraft, key: string | symbol) {\n    const source = latest(target);\n    const descriptor = Reflect.getOwnPropertyDescriptor(source, key);\n    if (!descriptor) return descriptor;\n    return {\n      writable: true,\n      configurable: target.type !== DraftType.Array || key !== 'length',\n      enumerable: descriptor.enumerable,\n      value: source[key],\n    };\n  },\n  getPrototypeOf(target: ProxyDraft) {\n    return Reflect.getPrototypeOf(target.original);\n  },\n  setPrototypeOf() {\n    throw new Error(`Cannot call 'setPrototypeOf()' on drafts`);\n  },\n  defineProperty() {\n    throw new Error(`Cannot call 'defineProperty()' on drafts`);\n  },\n  deleteProperty(target: ProxyDraft, key: string | symbol) {\n    if (target.type === DraftType.Array) {\n      return proxyHandler.set!.call(this, target, key, undefined, target.proxy);\n    }\n    if (peek(target.original, key) !== undefined || key in target.original) {\n      // !case: delete an existing key\n      ensureShallowCopy(target);\n      markChanged(target);\n      target.assignedMap!.set(key, false);\n    } else {\n      target.assignedMap = target.assignedMap ?? new Map();\n      // The original non-existent key has been deleted\n      target.assignedMap.delete(key);\n    }\n    if (target.copy) delete target.copy[key];\n    return true;\n  },\n};\n\nexport function createDraft<T extends object>(createDraftOptions: {\n  original: T;\n  parentDraft?: ProxyDraft | null;\n  key?: string | number | symbol;\n  finalities: Finalities;\n  options: Options<any, any>;\n}): T {\n  const { original, parentDraft, key, finalities, options } =\n    createDraftOptions;\n  const type = getType(original);\n  const proxyDraft: ProxyDraft = {\n    type,\n    finalized: false,\n    parent: parentDraft,\n    original,\n    copy: null,\n    proxy: null,\n    finalities,\n    options,\n    // Mapping of draft Set items to their corresponding draft values.\n    setMap:\n      type === DraftType.Set\n        ? new Map((original as Set<any>).entries())\n        : undefined,\n  };\n  // !case: undefined as a draft map key\n  if (key || 'key' in createDraftOptions) {\n    proxyDraft.key = key;\n  }\n  const { proxy, revoke } = Proxy.revocable<any>(\n    type === DraftType.Array ? Object.assign([], proxyDraft) : proxyDraft,\n    proxyHandler\n  );\n  finalities.revoke.push(revoke);\n  draftsCache.add(proxy);\n  proxyDraft.proxy = proxy;\n  if (parentDraft) {\n    const target = parentDraft;\n    target.finalities.draft.push((patches, inversePatches) => {\n      const oldProxyDraft = getProxyDraft(proxy)!;\n      // if target is a Set draft, `setMap` is the real Set copies proxy mapping.\n      let copy = target.type === DraftType.Set ? target.setMap : target.copy;\n      const draft = get(copy, key!);\n      const proxyDraft = getProxyDraft(draft);\n      if (proxyDraft) {\n        // assign the updated value to the copy object\n        let updatedValue = proxyDraft.original;\n        if (proxyDraft.operated) {\n          updatedValue = getValue(draft);\n        }\n        finalizeSetValue(proxyDraft);\n        finalizePatches(proxyDraft, generatePatches, patches, inversePatches);\n        if (__DEV__ && target.options.enableAutoFreeze) {\n          target.options.updatedValues =\n            target.options.updatedValues ?? new WeakMap();\n          target.options.updatedValues.set(updatedValue, proxyDraft.original);\n        }\n        // final update value\n        set(copy, key!, updatedValue);\n      }\n      // !case: handle the deleted key\n      oldProxyDraft.callbacks?.forEach((callback) => {\n        callback(patches, inversePatches);\n      });\n    });\n  } else {\n    // !case: handle the root draft\n    const target = getProxyDraft(proxy)!;\n    target.finalities.draft.push((patches, inversePatches) => {\n      finalizeSetValue(target);\n      finalizePatches(target, generatePatches, patches, inversePatches);\n    });\n  }\n  return proxy;\n}\n\ninternal.createDraft = createDraft;\n\nexport function finalizeDraft<T>(\n  result: T,\n  returnedValue: [T] | [],\n  patches?: Patches,\n  inversePatches?: Patches,\n  enableAutoFreeze?: boolean\n) {\n  const proxyDraft = getProxyDraft(result);\n  const original = proxyDraft?.original ?? result;\n  const hasReturnedValue = !!returnedValue.length;\n  if (proxyDraft?.operated) {\n    while (proxyDraft.finalities.draft.length > 0) {\n      const finalize = proxyDraft.finalities.draft.pop()!;\n      finalize(patches, inversePatches);\n    }\n  }\n  const state = hasReturnedValue\n    ? returnedValue[0]\n    : proxyDraft\n    ? proxyDraft.operated\n      ? proxyDraft.copy\n      : proxyDraft.original\n    : result;\n  if (proxyDraft) revokeProxy(proxyDraft);\n  if (enableAutoFreeze) {\n    deepFreeze(state, state, proxyDraft?.options.updatedValues);\n  }\n  return [\n    state,\n    patches && hasReturnedValue\n      ? [{ op: Operation.Replace, path: [], value: returnedValue[0] }]\n      : patches,\n    inversePatches && hasReturnedValue\n      ? [{ op: Operation.Replace, path: [], value: original }]\n      : inversePatches,\n  ] as [T, Patches | undefined, Patches | undefined];\n}\n", "import {\n  Finalities,\n  Options,\n  Patches,\n  PatchesOptions,\n  Result,\n} from './interface';\nimport { createDraft, finalizeDraft } from './draft';\nimport { isDraftable } from './utils';\nimport { dataTypes } from './constant';\n\nexport function draftify<\n  T extends object,\n  O extends PatchesOptions = false,\n  F extends boolean = false\n>(\n  baseState: T,\n  options: Options<O, F>\n): [T, (returnedValue: [T] | []) => Result<T, O, F>] {\n  const finalities: Finalities = {\n    draft: [],\n    revoke: [],\n    handledSet: new WeakSet<any>(),\n  };\n  let patches: Patches | undefined;\n  let inversePatches: Patches | undefined;\n  if (options.enablePatches) {\n    patches = [];\n    inversePatches = [];\n  }\n  const isMutable =\n    options.mark?.(baseState, dataTypes) === dataTypes.mutable ||\n    !isDraftable(baseState, options);\n  const draft = isMutable\n    ? baseState\n    : createDraft({\n        original: baseState,\n        parentDraft: null,\n        finalities,\n        options,\n      });\n  return [\n    draft,\n    (returnedValue: [T] | [] = []) => {\n      const [finalizedState, finalizedPatches, finalizedInversePatches] =\n        finalizeDraft(\n          draft,\n          returnedValue,\n          patches,\n          inversePatches,\n          options.enableAutoFreeze\n        );\n      return (\n        options.enablePatches\n          ? [finalizedState, finalizedPatches, finalizedInversePatches]\n          : finalizedState\n      ) as Result<T, O, F>;\n    },\n  ];\n}\n", "import { type Draft, DraftType, type ProxyDraft } from './interface';\nimport {\n  forEach,\n  get,\n  getProxyDraft,\n  getType,\n  isBaseMapInstance,\n  isBaseSetInstance,\n  isDraft,\n  isDraftable,\n  isEqual,\n  set,\n  shallowCopy,\n} from './utils';\n\nexport function handleReturnValue<T extends object>(options: {\n  rootDraft: ProxyDraft<any> | undefined;\n  value: T;\n  useRawReturn?: boolean;\n  isContainDraft?: boolean;\n  isRoot?: boolean;\n}) {\n  const { rootDraft, value, useRawReturn = false, isRoot = true } = options;\n  forEach(value, (key, item, source) => {\n    const proxyDraft = getProxyDraft(item);\n    // just handle the draft which is created by the same rootDraft\n    if (\n      proxyDraft &&\n      rootDraft &&\n      proxyDraft.finalities === rootDraft.finalities\n    ) {\n      options.isContainDraft = true;\n      const currentValue = proxyDraft.original;\n      // final update value, but just handle return value\n      if (source instanceof Set) {\n        const arr = Array.from(source);\n        source.clear();\n        arr.forEach((_item) =>\n          source.add(key === _item ? currentValue : _item)\n        );\n      } else {\n        set(source, key, currentValue);\n      }\n    } else if (typeof item === 'object' && item !== null) {\n      options.value = item;\n      options.isRoot = false;\n      handleReturnValue(options);\n    }\n  });\n  if (__DEV__ && isRoot) {\n    if (!options.isContainDraft)\n      console.warn(\n        `The return value does not contain any draft, please use 'rawReturn()' to wrap the return value to improve performance.`\n      );\n\n    if (useRawReturn) {\n      console.warn(\n        `The return value contains drafts, please don't use 'rawReturn()' to wrap the return value.`\n      );\n    }\n  }\n}\n\nfunction getCurrent(target: any) {\n  const proxyDraft = getProxyDraft(target);\n  if (!isDraftable(target, proxyDraft?.options)) return target;\n  const type = getType(target);\n  if (proxyDraft && !proxyDraft.operated) return proxyDraft.original;\n  let currentValue: any;\n  function ensureShallowCopy() {\n    currentValue =\n      type === DraftType.Map\n        ? !isBaseMapInstance(target)\n          ? new (Object.getPrototypeOf(target).constructor)(target)\n          : new Map(target)\n        : type === DraftType.Set\n          ? Array.from(proxyDraft!.setMap!.values()!)\n          : shallowCopy(target, proxyDraft?.options);\n  }\n\n  if (proxyDraft) {\n    // It's a proxy draft, let's create a shallow copy eagerly\n    proxyDraft.finalized = true;\n    try {\n      ensureShallowCopy();\n    } finally {\n      proxyDraft.finalized = false;\n    }\n  } else {\n    // It's not a proxy draft, let's use the target directly and let's see\n    // lazily if we need to create a shallow copy\n    currentValue = target;\n  }\n\n  forEach(currentValue, (key, value) => {\n    if (proxyDraft && isEqual(get(proxyDraft.original, key), value)) return;\n    const newValue = getCurrent(value);\n    if (newValue !== value) {\n      if (currentValue === target) ensureShallowCopy();\n      set(currentValue, key, newValue);\n    }\n  });\n  if (type === DraftType.Set) {\n    const value = proxyDraft?.original ?? currentValue;\n    return !isBaseSetInstance(value)\n      ? new (Object.getPrototypeOf(value).constructor)(currentValue)\n      : new Set(currentValue);\n  }\n  return currentValue;\n}\n\n/**\n * `current(draft)` to get current state in the draft mutation function.\n *\n * ## Example\n *\n * ```ts\n * import { create, current } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *     expect(current(draft.foo)).toEqual({ bar: 'str2' });\n *   },\n * );\n * ```\n */\nexport function current<T extends object>(target: Draft<T>): T;\n/** @deprecated You should call current only on `Draft<T>` types. */\nexport function current<T extends object>(target: T): T;\nexport function current<T extends object>(target: T | Draft<T>): T {\n  if (!isDraft(target)) {\n    throw new Error(`current() is only used for Draft, parameter: ${target}`);\n  }\n  return getCurrent(target);\n}\n", "import {\n  CreateResult,\n  Draft,\n  Mark,\n  Options,\n  ExternalOptions,\n  PatchesOptions,\n  Result,\n} from './interface';\nimport { draftify } from './draftify';\nimport {\n  getProxyDraft,\n  isDraft,\n  isDraftable,\n  isEqual,\n  revokeProxy,\n} from './utils';\nimport { current, handleReturnValue } from './current';\nimport { RAW_RETURN_SYMBOL, dataTypes } from './constant';\n\ntype MakeCreator = <\n  _F extends boolean = false,\n  _O extends PatchesOptions = false\n>(\n  options?: ExternalOptions<_O, _F>\n) => {\n  <\n    T extends any,\n    F extends boolean = _F,\n    O extends PatchesOptions = _O,\n    R extends void | Promise<void> | T | Promise<T> = void\n  >(\n    base: T,\n    mutate: (draft: Draft<T>) => R,\n    options?: ExternalOptions<O, F>\n  ): CreateResult<T, O, F, R>;\n  <\n    T extends any,\n    F extends boolean = _F,\n    O extends PatchesOptions = _O,\n    R extends void | Promise<void> = void\n  >(\n    base: T,\n    mutate: (draft: T) => R,\n    options?: ExternalOptions<O, F>\n  ): CreateResult<T, O, F, R>;\n  <\n    T extends any,\n    P extends any[] = [],\n    F extends boolean = _F,\n    O extends PatchesOptions = _O,\n    R extends void | Promise<void> = void\n  >(\n    mutate: (draft: Draft<T>, ...args: P) => R,\n    options?: ExternalOptions<O, F>\n  ): (base: T, ...args: P) => CreateResult<T, O, F, R>;\n  <T extends any, O extends PatchesOptions = _O, F extends boolean = _F>(\n    base: T,\n    options?: ExternalOptions<O, F>\n  ): [Draft<T>, () => Result<T, O, F>];\n};\n\n/**\n * `makeCreator(options)` to make a creator function.\n *\n * ## Example\n *\n * ```ts\n * import { makeCreator } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const create = makeCreator({ enableAutoFreeze: true });\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n * );\n *\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(state).not.toBe(baseState);\n * expect(state.foo).not.toBe(baseState.foo);\n * expect(state.arr).toBe(baseState.arr);\n * expect(Object.isFrozen(state)).toBeTruthy();\n * ```\n */\nexport const makeCreator: MakeCreator = (arg) => {\n  if (\n    __DEV__ &&\n    arg !== undefined &&\n    Object.prototype.toString.call(arg) !== '[object Object]'\n  ) {\n    throw new Error(\n      `Invalid options: ${String(arg)}, 'options' should be an object.`\n    );\n  }\n  return function create(arg0: any, arg1: any, arg2?: any): any {\n    if (typeof arg0 === 'function' && typeof arg1 !== 'function') {\n      return function (this: any, base: any, ...args: any[]) {\n        return create(\n          base,\n          (draft: any) => arg0.call(this, draft, ...args),\n          arg1\n        );\n      };\n    }\n    const base = arg0;\n    const mutate = arg1 as (...args: any[]) => any;\n    let options = arg2;\n    if (typeof arg1 !== 'function') {\n      options = arg1;\n    }\n    if (\n      __DEV__ &&\n      options !== undefined &&\n      Object.prototype.toString.call(options) !== '[object Object]'\n    ) {\n      throw new Error(\n        `Invalid options: ${options}, 'options' should be an object.`\n      );\n    }\n    options = {\n      ...arg,\n      ...options,\n    };\n    const state = isDraft(base) ? current(base) : base;\n    const mark = Array.isArray(options.mark)\n      ? (((value: unknown, types: typeof dataTypes) => {\n          for (const mark of options.mark as Mark<any, any>[]) {\n            if (__DEV__ && typeof mark !== 'function') {\n              throw new Error(\n                `Invalid mark: ${mark}, 'mark' should be a function.`\n              );\n            }\n            const result = mark(value, types);\n            if (result) {\n              return result;\n            }\n          }\n          return;\n        }) as Mark<any, any>)\n      : options.mark;\n    const enablePatches = options.enablePatches ?? false;\n    const strict = options.strict ?? false;\n    const enableAutoFreeze = options.enableAutoFreeze ?? false;\n    const _options: Options<any, any> = {\n      enableAutoFreeze,\n      mark,\n      strict,\n      enablePatches,\n    };\n    if (\n      !isDraftable(state, _options) &&\n      typeof state === 'object' &&\n      state !== null\n    ) {\n      throw new Error(\n        `Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`\n      );\n    }\n    const [draft, finalize] = draftify(state, _options);\n    if (typeof arg1 !== 'function') {\n      if (!isDraftable(state, _options)) {\n        throw new Error(\n          `Invalid base state: create() only supports plain objects, arrays, Set, Map or using mark() to mark the state as immutable.`\n        );\n      }\n      return [draft, finalize];\n    }\n    let result: any;\n    try {\n      result = mutate(draft);\n    } catch (error) {\n      revokeProxy(getProxyDraft(draft));\n      throw error;\n    }\n    const returnValue = (value: any) => {\n      const proxyDraft = getProxyDraft(draft)!;\n      if (!isDraft(value)) {\n        if (\n          value !== undefined &&\n          !isEqual(value, draft) &&\n          proxyDraft?.operated\n        ) {\n          throw new Error(\n            `Either the value is returned as a new non-draft value, or only the draft is modified without returning any value.`\n          );\n        }\n        const rawReturnValue = value?.[RAW_RETURN_SYMBOL] as [any] | undefined;\n        if (rawReturnValue) {\n          const _value = rawReturnValue[0];\n          if (_options.strict && typeof value === 'object' && value !== null) {\n            handleReturnValue({\n              rootDraft: proxyDraft,\n              value,\n              useRawReturn: true,\n            });\n          }\n          return finalize([_value]);\n        }\n        if (value !== undefined) {\n          if (typeof value === 'object' && value !== null) {\n            handleReturnValue({ rootDraft: proxyDraft, value });\n          }\n          return finalize([value]);\n        }\n      }\n      if (value === draft || value === undefined) {\n        return finalize([]);\n      }\n      const returnedProxyDraft = getProxyDraft(value)!;\n      if (_options === returnedProxyDraft.options) {\n        if (returnedProxyDraft.operated) {\n          throw new Error(`Cannot return a modified child draft.`);\n        }\n        return finalize([current(value)]);\n      }\n      return finalize([value]);\n    };\n    if (result instanceof Promise) {\n      return result.then(returnValue, (error) => {\n        revokeProxy(getProxyDraft(draft)!);\n        throw error;\n      });\n    }\n    return returnValue(result);\n  };\n};\n", "import { makeCreator } from './makeCreator';\n\n/**\n * `create(baseState, callback, options)` to create the next state\n *\n * ## Example\n *\n * ```ts\n * import { create } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n * );\n *\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(state).not.toBe(baseState);\n * expect(state.foo).not.toBe(baseState.foo);\n * expect(state.arr).toBe(baseState.arr);\n * ```\n */\nconst create = makeCreator();\n\nexport { create };\n", "import { Operation, DraftType } from './interface';\nimport type {\n  Draft,\n  Patches,\n  ApplyMutableOptions,\n  ApplyOptions,\n  ApplyResult,\n} from './interface';\nimport { deepClone, get, getType, isDraft, unescapePath } from './utils';\nimport { create } from './create';\n\n/**\n * `apply(state, patches)` to apply patches to state\n *\n * ## Example\n *\n * ```ts\n * import { create, apply } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const [state, patches] = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *   },\n *   { enablePatches: true }\n * );\n * expect(state).toEqual({ foo: { bar: 'str2' }, arr: [] });\n * expect(patches).toEqual([{ op: 'replace', path: ['foo', 'bar'], value: 'str2' }]);\n * expect(state).toEqual(apply(baseState, patches));\n * ```\n */\nexport function apply<\n  T extends object,\n  F extends boolean = false,\n  A extends ApplyOptions<F> = ApplyOptions<F>,\n>(state: T, patches: Patches, applyOptions?: A): ApplyResult<T, F, A> {\n  let i: number;\n  for (i = patches.length - 1; i >= 0; i -= 1) {\n    const { value, op, path } = patches[i];\n    if (\n      (!path.length && op === Operation.Replace) ||\n      (path === '' && op === Operation.Add)\n    ) {\n      state = value;\n      break;\n    }\n  }\n  if (i > -1) {\n    patches = patches.slice(i + 1);\n  }\n  const mutate = (draft: Draft<T> | T) => {\n    patches.forEach((patch) => {\n      const { path: _path, op } = patch;\n      const path = unescapePath(_path);\n      let base: any = draft;\n      for (let index = 0; index < path.length - 1; index += 1) {\n        const parentType = getType(base);\n        let key = path[index];\n        if (typeof key !== 'string' && typeof key !== 'number') {\n          key = String(key);\n        }\n        if (\n          ((parentType === DraftType.Object ||\n            parentType === DraftType.Array) &&\n            (key === '__proto__' || key === 'constructor')) ||\n          (typeof base === 'function' && key === 'prototype')\n        ) {\n          throw new Error(\n            `Patching reserved attributes like __proto__ and constructor is not allowed.`\n          );\n        }\n        // use `index` in Set draft\n        base = get(parentType === DraftType.Set ? Array.from(base) : base, key);\n        if (typeof base !== 'object') {\n          throw new Error(`Cannot apply patch at '${path.join('/')}'.`);\n        }\n      }\n\n      const type = getType(base);\n      // ensure the original patch is not modified.\n      const value = deepClone(patch.value);\n      const key = path[path.length - 1];\n      switch (op) {\n        case Operation.Replace:\n          switch (type) {\n            case DraftType.Map:\n              return base.set(key, value);\n            case DraftType.Set:\n              throw new Error(`Cannot apply replace patch to set.`);\n            default:\n              return (base[key] = value);\n          }\n        case Operation.Add:\n          switch (type) {\n            case DraftType.Array:\n              // If the \"-\" character is used to\n              // index the end of the array (see [RFC6901](https://datatracker.ietf.org/doc/html/rfc6902)),\n              // this has the effect of appending the value to the array.\n              return key === '-'\n                ? base.push(value)\n                : base.splice(key as number, 0, value);\n            case DraftType.Map:\n              return base.set(key, value);\n            case DraftType.Set:\n              return base.add(value);\n            default:\n              return (base[key] = value);\n          }\n        case Operation.Remove:\n          switch (type) {\n            case DraftType.Array:\n              return base.splice(key as number, 1);\n            case DraftType.Map:\n              return base.delete(key);\n            case DraftType.Set:\n              return base.delete(patch.value);\n            default:\n              return delete base[key];\n          }\n        default:\n          throw new Error(`Unsupported patch operation: ${op}.`);\n      }\n    });\n  };\n  if ((applyOptions as ApplyMutableOptions)?.mutable) {\n    if (__DEV__) {\n      if (\n        Object.keys(applyOptions!).filter((key) => key !== 'mutable').length\n      ) {\n        console.warn(\n          'The \"mutable\" option is not allowed to be used with other options.'\n        );\n      }\n    }\n    mutate(state);\n    return undefined as ApplyResult<T, F, A>;\n  }\n  if (isDraft(state)) {\n    if (applyOptions !== undefined) {\n      throw new Error(`Cannot apply patches with options to a draft.`);\n    }\n    mutate(state as Draft<T>);\n    return state as ApplyResult<T, F, A>;\n  }\n  return create<T, F>(state, mutate, {\n    ...applyOptions,\n    enablePatches: false,\n  }) as T as ApplyResult<T, F, A>;\n}\n", "import { getProxyDraft } from './utils';\n\n/**\n * `original(draft)` to get original state in the draft mutation function.\n *\n * ## Example\n *\n * ```ts\n * import { create, original } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     draft.foo.bar = 'str2';\n *     expect(original(draft.foo)).toEqual({ bar: 'str' });\n *   }\n * );\n * ```\n */\nexport function original<T>(target: T): T {\n  const proxyDraft = getProxyDraft(target);\n  if (!proxyDraft) {\n    throw new Error(\n      `original() is only used for a draft, parameter: ${target}`\n    );\n  }\n  return proxyDraft.original;\n}\n", "import { RAW_RETURN_SYMBOL } from './constant';\n\n/**\n * Use rawReturn() to wrap the return value to skip the draft check and thus improve performance.\n *\n * ## Example\n *\n * ```ts\n * import { create, rawReturn } from '../index';\n *\n * const baseState = { foo: { bar: 'str' }, arr: [] };\n * const state = create(\n *   baseState,\n *   (draft) => {\n *     return rawReturn(baseState);\n *   },\n * );\n * expect(state).toBe(baseState);\n * ```\n */\nexport function rawReturn<T extends object | undefined>(value: T): T {\n  if (arguments.length === 0) {\n    throw new Error('rawReturn() must be called with a value.');\n  }\n  if (arguments.length > 1) {\n    throw new Error('rawReturn() must be called with one argument.');\n  }\n  if (\n    __DEV__ &&\n    value !== undefined &&\n    (typeof value !== 'object' || value === null)\n  ) {\n    console.warn(\n      'rawReturn() must be called with an object(including plain object, arrays, Set, Map, etc.) or `undefined`, other types do not need to be returned via rawReturn().'\n    );\n  }\n  return {\n    [RAW_RETURN_SYMBOL]: [value],\n  } as never;\n}\n", "import { dataTypes } from '../constant';\n\nconst constructorString = Object.prototype.constructor.toString();\n/**\n * Check if the value is a simple object(No prototype chain object or iframe same-origin object),\n * support case: https://github.com/unadlib/mutative/issues/17\n */\nconst isSimpleObject = (value: unknown) => {\n  if (!value || typeof value !== 'object') return false;\n  const prototype = Object.getPrototypeOf(value);\n  if (prototype === null) {\n    return true;\n  }\n  const constructor =\n    Object.hasOwnProperty.call(prototype, 'constructor') &&\n    prototype.constructor;\n\n  if (constructor === Object) return true;\n\n  return (\n    typeof constructor === 'function' &&\n    Function.toString.call(constructor) === constructorString\n  );\n};\n\nexport const markSimpleObject = (value: unknown) => {\n  if (isSimpleObject(value)) {\n    return dataTypes.immutable;\n  }\n  return;\n};\n", "import { Draft, Immutable } from '../interface';\n\n/**\n * Cast a value to an Draft type value.\n */\nexport function castDraft<T>(value: T): Draft<T> {\n  return value as any;\n}\n\n/**\n * Cast a value to an Immutable type value.\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n  return value as any;\n}\n\n/**\n * Cast a value to an Mutable type value.\n */\nexport function castMutable<T>(draft: Draft<T>): T {\n  return draft as any;\n}\n", "import { create, } from 'mutative';\nimport { useState, useReducer, useCallback, useMemo, useRef, useEffect, } from 'react';\n/**\n * `useMutative` is a hook that is similar to `useState` but it uses `mutative` to handle the state updates.\n *\n *  @example\n *\n * ```ts\n * import { act, renderHook } from '@testing-library/react';\n *\n * import { useMutative } from '../src/index';\n *\n * const { result } = renderHook(() => useMutative({ items: [1] }));\n * const [state, updateState] = result.current;\n * act(() =>\n *   updateState((draft) => {\n *     draft.items.push(2);\n *   })\n * );\n * const [nextState] = result.current;\n * expect(nextState).toEqual({ items: [1, 2] });\n * ```\n */\nfunction useMutative(\n/**\n * The initial state. You may optionally provide an initializer function to calculate the initial state.\n */\ninitialValue, \n/**\n * Options for the `useMutative` hook.\n */\noptions) {\n    const patchesRef = useRef({\n        patches: [],\n        inversePatches: [],\n    });\n    //#region support strict mode and concurrent features\n    const count = useRef(0);\n    const renderCount = useRef(0);\n    let currentCount = count.current;\n    useEffect(() => {\n        count.current = currentCount;\n        renderCount.current = currentCount;\n    });\n    currentCount += 1;\n    renderCount.current += 1;\n    //#endregion\n    const [state, setState] = useState(() => typeof initialValue === 'function' ? initialValue() : initialValue);\n    const updateState = useCallback((updater) => {\n        setState((latest) => {\n            const updaterFn = typeof updater === 'function' ? updater : () => updater;\n            const result = create(latest, updaterFn, options);\n            if (options === null || options === void 0 ? void 0 : options.enablePatches) {\n                // check render count, support strict mode and concurrent features\n                if (renderCount.current === count.current ||\n                    renderCount.current === count.current + 1) {\n                    Array.prototype.push.apply(patchesRef.current.patches, result[1]);\n                    // `inversePatches` should be in reverse order when multiple setState() executions\n                    Array.prototype.unshift.apply(patchesRef.current.inversePatches, result[2]);\n                }\n                return result[0];\n            }\n            return result;\n        });\n    }, []);\n    useEffect(() => {\n        if (options === null || options === void 0 ? void 0 : options.enablePatches) {\n            // Reset `patchesRef` when the component is rendered each time\n            patchesRef.current.patches = [];\n            patchesRef.current.inversePatches = [];\n        }\n    });\n    return ((options === null || options === void 0 ? void 0 : options.enablePatches)\n        ? [\n            state,\n            updateState,\n            patchesRef.current.patches,\n            patchesRef.current.inversePatches,\n        ]\n        : [state, updateState]);\n}\n/**\n * `useMutativeReducer` is a hook that is similar to `useReducer` but it uses `mutative` to handle the state updates.\n *\n * @example\n *\n * ```ts\n * import { act, renderHook } from '@testing-library/react';\n * import { type Draft } from 'mutative';\n *\n * import { useMutativeReducer } from '../src/index';\n *\n * const { result } = renderHook(() =>\n *   useMutativeReducer(\n *     (\n *       draft: Draft<Readonly<{ count: number }>>,\n *       action: {\n *         type: 'increment';\n *       }\n *     ) => {\n *       switch (action.type) {\n *         case 'increment':\n *           draft.count += 1;\n *       }\n *     },\n *     { count: 0 }\n *   )\n * );\n * const [, dispatch] = result.current;\n * act(() => dispatch({ type: 'increment' }));\n * expect(result.current[0]).toEqual({ count: 1 });\n * ```\n */\nfunction useMutativeReducer(\n/**\n * A function that returns the next state tree, given the current state tree and the action to handle.\n */\nreducer, \n/**\n * The initial state. You may optionally provide an initializer function to calculate the initial state.\n */\ninitializerArg, \n/**\n * An initializer function that returns the initial state. It will be called with `initializerArg`.\n */\ninitializer, \n/**\n * Options for the `useMutativeReducer` hook.\n */\noptions) {\n    const patchesRef = useRef({\n        patches: [],\n        inversePatches: [],\n    });\n    //#region support strict mode and concurrent features\n    const count = useRef(0);\n    const renderCount = useRef(0);\n    let currentCount = count.current;\n    useEffect(() => {\n        count.current = currentCount;\n        renderCount.current = currentCount;\n    });\n    currentCount += 1;\n    renderCount.current += 1;\n    //#endregion\n    const cachedReducer = useMemo(() => (state, action) => {\n        const result = create(state, (draft) => reducer(draft, action), options);\n        if (options === null || options === void 0 ? void 0 : options.enablePatches) {\n            // check render count, support strict mode and concurrent features\n            if (renderCount.current === count.current ||\n                renderCount.current === count.current + 1) {\n                Array.prototype.push.apply(patchesRef.current.patches, result[1]);\n                // `inversePatches` should be in reverse order when multiple setState() executions\n                Array.prototype.unshift.apply(patchesRef.current.inversePatches, result[2]);\n            }\n            return result[0];\n        }\n        return result;\n    }, [reducer]);\n    const result = useReducer(cachedReducer, initializerArg, initializer);\n    useEffect(() => {\n        if (options === null || options === void 0 ? void 0 : options.enablePatches) {\n            // Reset `patchesRef` when the component is rendered each time\n            patchesRef.current.patches = [];\n            patchesRef.current.inversePatches = [];\n        }\n    });\n    return (options === null || options === void 0 ? void 0 : options.enablePatches)\n        ? [\n            result[0],\n            result[1],\n            patchesRef.current.patches,\n            patchesRef.current.inversePatches,\n        ]\n        : result;\n}\nexport { useMutative, useMutativeReducer, };\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLE1BQU0sR0FLUCxNQUFNLFVBQVUsQ0FBQztBQUNsQixPQUFPLEVBQ0wsUUFBUSxFQUNSLFVBQVUsRUFDVixXQUFXLEVBQ1gsT0FBTyxFQUNQLE1BQU0sRUFFTixTQUFTLEdBQ1YsTUFBTSxPQUFPLENBQUM7QUE0QmY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBb0JHO0FBQ0gsU0FBUyxXQUFXO0FBS2xCOztHQUVHO0FBQ0gsWUFBZTtBQUNmOztHQUVHO0FBQ0gsT0FBdUI7SUFFdkIsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUd0QjtRQUNELE9BQU8sRUFBRSxFQUFFO1FBQ1gsY0FBYyxFQUFFLEVBQUU7S0FDbkIsQ0FBQyxDQUFDO0lBQ0gscURBQXFEO0lBQ3JELE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN4QixNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDOUIsSUFBSSxZQUFZLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQztJQUNqQyxTQUFTLENBQUMsR0FBRyxFQUFFO1FBQ2IsS0FBSyxDQUFDLE9BQU8sR0FBRyxZQUFZLENBQUM7UUFDN0IsV0FBVyxDQUFDLE9BQU8sR0FBRyxZQUFZLENBQUM7SUFDckMsQ0FBQyxDQUFDLENBQUM7SUFDSCxZQUFZLElBQUksQ0FBQyxDQUFDO0lBQ2xCLFdBQVcsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDO0lBQ3pCLFlBQVk7SUFDWixNQUFNLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FDdEMsT0FBTyxZQUFZLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUNuRSxDQUFDO0lBQ0YsTUFBTSxXQUFX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TyxHQUFHLEVBQUUsQ0FBQztZQUNoQyxVQUFVLENBQUMsT0FBTyxDQUFDLGNBQWMsR0FBRyxFQUFFLENBQUM7UUFDekMsQ0FBQztJQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0gsT0FBTyxDQUFBLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSxhQUFhO1FBQzNCLENBQUMsQ0FBQztZQUNFLE1BQU0sQ0FBQyxDQUFDLENBQUM7WUFDVCxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ1QsVUFBVSxDQUFDLE9BQU8sQ0FBQyxPQUFPO1lBQzFCLFVBQVUsQ0FBQyxPQUFPLENBQUMsY0FBYztTQUNMO1FBQ2hDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDYixDQUFDO0FBRUQsT0FBTyxFQUlMLFdBQVcsRUFDWCxrQkFBa0IsR0FDbkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGNyZWF0ZSxcbiAgdHlwZSBJbW11dGFibGUsXG4gIHR5cGUgUGF0Y2hlcyxcbiAgdHlwZSBPcHRpb25zLFxuICB0eXBlIERyYWZ0LFxufSBmcm9tICdtdXRhdGl2ZSc7XG5pbXBvcnQge1xuICB1c2VTdGF0ZSxcbiAgdXNlUmVkdWNlcixcbiAgdXNlQ2FsbGJhY2ssXG4gIHVzZU1lbW8sXG4gIHVzZVJlZixcbiAgRGlzcGF0Y2gsXG4gIHVzZUVmZmVjdCxcbn0gZnJvbSAncmVhY3QnO1xuXG50eXBlIFBhdGNoZXNPcHRpb25zID1cbiAgfCBib29sZWFuXG4gIHwge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAuIElmIGl0J3MgYHRydWVgLCB0aGUgcGF0aCB3aWxsIGJlIGFuIGFycmF5LCBvdGhlcndpc2UgaXQgaXMgYSBzdHJpbmcuXG4gICAgICAgKi9cbiAgICAgIHBhdGhBc0FycmF5PzogYm9vbGVhbjtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgYHRydWVgLiBJZiBpdCdzIGB0cnVlYCwgdGhlIGFycmF5IGxlbmd0aCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBwYXRjaGVzLCBvdGhlcndpc2Ugbm8gaW5jbHVkZSBhcnJheSBsZW5ndGguXG4gICAgICAgKi9cbiAgICAgIGFycmF5TGVuZ3RoQXNzaWdubWVudD86IGJvb2xlYW47XG4gICAgfTtcblxudHlwZSBEcmFmdEZ1bmN0aW9uPFM+ID0gKGRyYWZ0OiBEcmFmdDxTPikgPT4gdm9pZDtcbnR5cGUgVXBkYXRlcjxTPiA9ICh2YWx1ZTogUyB8ICgoKSA9PiBTKSB8IERyYWZ0RnVuY3Rpb248Uz4pID0+IHZvaWQ7XG5cbnR5cGUgSW5pdGlhbFZhbHVlPEkgZXh0ZW5kcyBhbnk+ID0gSSBleHRlbmRzICguLi5hcmdzOiBhbnkpID0+IGluZmVyIFIgPyBSIDogSTtcblxudHlwZSBSZXN1bHQ8UywgTyBleHRlbmRzIFBhdGNoZXNPcHRpb25zLCBGIGV4dGVuZHMgYm9vbGVhbj4gPSBPIGV4dGVuZHNcbiAgfCB0cnVlXG4gIHwgb2JqZWN0XG4gID8gW0YgZXh0ZW5kcyB0cnVlID8gSW1tdXRhYmxlPFM+IDogUywgVXBkYXRlcjxTPiwgUGF0Y2hlczxPPiwgUGF0Y2hlczxPPl1cbiAgOiBGIGV4dGVuZHMgdHJ1ZVxuICAgID8gW0ltbXV0YWJsZTxTPiwgVXBkYXRlcjxTPl1cbiAgICA6IFtTLCBVcGRhdGVyPFM+XTtcblxuLyoqXG4gKiBgdXNlTXV0YXRpdmVgIGlzIGEgaG9vayB0aGF0IGlzIHNpbWlsYXIgdG8gYHVzZVN0YXRlYCBidXQgaXQgdXNlcyBgbXV0YXRpdmVgIHRvIGhhbmRsZSB0aGUgc3RhdGUgdXBkYXRlcy5cbiAqXG4gKiAgQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgYWN0LCByZW5kZXJIb29rIH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9yZWFjdCc7XG4gKlxuICogaW1wb3J0IHsgdXNlTXV0YXRpdmUgfSBmcm9tICcuLi9zcmMvaW5kZXgnO1xuICpcbiAqIGNvbnN0IHsgcmVzdWx0IH0gPSByZW5kZXJIb29rKCgpID0+IHVzZU11dGF0aXZlKHsgaXRlbXM6IFsxXSB9KSk7XG4gKiBjb25zdCBbc3RhdGUsIHVwZGF0ZVN0YXRlXSA9IHJlc3VsdC5jdXJyZW50O1xuICogYWN0KCgpID0+XG4gKiAgIHVwZGF0ZVN0YXRlKChkcmFmdCkgPT4ge1xuICogICAgIGRyYWZ0Lml0ZW1zLnB1c2goMik7XG4gKiAgIH0pXG4gKiApO1xuICogY29uc3QgW25leHRTdGF0ZV0gPSByZXN1bHQuY3VycmVudDtcbiAqIGV4cGVjdChuZXh0U3RhdGUpLnRvRXF1YWwoeyBpdGVtczogWzEsIDJdIH0pO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZU11dGF0aXZlPFxuICBTLFxuICBGIGV4dGVuZHMgYm9vbGVhbiA9IGZhbHNlLFxuICBPIGV4dGVuZHMgUGF0Y2hlc09wdGlvbnMgPSBmYWxzZSxcbj4oXG4gIC8qKlxuICAgKiBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHByb3ZpZGUgYW4gaW5pdGlhbGl6ZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZSBpbml0aWFsIHN0YXRlLlxuICAgKi9cbiAgaW5pdGlhbFZhbHVlOiBTLFxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgdGhlIGB1c2VNdXRhdGl2ZWAgaG9vay5cbiAgICovXG4gIG9wdGlvbnM/OiBPcHRpb25zPE8sIEY+XG4pIHtcbiAgY29uc3QgcGF0Y2hlc1JlZiA9IHVzZVJlZjx7XG4gICAgcGF0Y2hlczogUGF0Y2hlcztcbiAgICBpbnZlcnNlUGF0Y2hlczogUGF0Y2hlcztcbiAgfT4oe1xuICAgIHBhdGNoZXM6IFtdLFxuICAgIGludmVyc2VQYXRjaGVzOiBbXSxcbiAgfSk7XG4gIC8vI3JlZ2lvbiBzdXBwb3J0IHN0cmljdCBtb2RlIGFuZCBjb25jdXJyZW50IGZlYXR1cmVzXG4gIGNvbnN0IGNvdW50ID0gdXNlUmVmKDApO1xuICBjb25zdCByZW5kZXJDb3VudCA9IHVzZVJlZigwKTtcbiAgbGV0IGN1cnJlbnRDb3VudCA9IGNvdW50LmN1cnJlbnQ7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY291bnQuY3VycmVudCA9IGN1cnJlbnRDb3VudDtcbiAgICByZW5kZXJDb3VudC5jdXJyZW50ID0gY3VycmVudENvdW50O1xuICB9KTtcbiAgY3VycmVudENvdW50ICs9IDE7XG4gIHJlbmRlckNvdW50LmN1cnJlbnQgKz0gMTtcbiAgLy8jZW5kcmVnaW9uXG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUoKCkgPT5cbiAgICB0eXBlb2YgaW5pdGlhbFZhbHVlID09PSAnZnVuY3Rpb24nID8gaW5pdGlhbFZhbHVlKCkgOiBpbml0aWFsVmFsdWVcbiAgKTtcbiAgY29uc3QgdXBkYXRlU3RhdGUgPSB1c2VDYWxsYmFjaygodXBkYXRlcjogYW55KSA9PiB7XG4gICAgc2V0U3RhdGUoKGxhdGVzdDogYW55KSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGVyRm4gPSB0eXBlb2YgdXBkYXRlciA9PT0gJ2Z1bmN0aW9uJyA/IHVwZGF0ZXIgOiAoKSA9PiB1cGRhdGVyO1xuICAgICAgY29uc3QgcmVzdWx0ID0gY3JlYXRlKGxhdGVzdCwgdXBkYXRlckZuLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zPy5lbmFibGVQYXRjaGVzKSB7XG4gICAgICAgIC8vIGNoZWNrIHJlbmRlciBjb3VudCwgc3VwcG9ydCBzdHJpY3QgbW9kZSBhbmQgY29uY3VycmVudCBmZWF0dXJlc1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcmVuZGVyQ291bnQuY3VycmVudCA9PT0gY291bnQuY3VycmVudCB8fFxuICAgICAgICAgIHJlbmRlckNvdW50LmN1cnJlbnQgPT09IGNvdW50LmN1cnJlbnQgKyAxXG4gICAgICAgICkge1xuICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHBhdGNoZXNSZWYuY3VycmVudC5wYXRjaGVzLCByZXN1bHRbMV0pO1xuICAgICAgICAgIC8vIGBpbnZlcnNlUGF0Y2hlc2Agc2hvdWxkIGJlIGluIHJldmVyc2Ugb3JkZXIgd2hlbiBtdWx0aXBsZSBzZXRTdGF0ZSgpIGV4ZWN1dGlvbnNcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShcbiAgICAgICAgICAgIHBhdGNoZXNSZWYuY3VycmVudC5pbnZlcnNlUGF0Y2hlcyxcbiAgICAgICAgICAgIHJlc3VsdFsyXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAob3B0aW9ucz8uZW5hYmxlUGF0Y2hlcykge1xuICAgICAgLy8gUmVzZXQgYHBhdGNoZXNSZWZgIHdoZW4gdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZCBlYWNoIHRpbWVcbiAgICAgIHBhdGNoZXNSZWYuY3VycmVudC5wYXRjaGVzID0gW107XG4gICAgICBwYXRjaGVzUmVmLmN1cnJlbnQuaW52ZXJzZVBhdGNoZXMgPSBbXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gKFxuICAgIG9wdGlvbnM/LmVuYWJsZVBhdGNoZXNcbiAgICAgID8gW1xuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIHVwZGF0ZVN0YXRlLFxuICAgICAgICAgIHBhdGNoZXNSZWYuY3VycmVudC5wYXRjaGVzLFxuICAgICAgICAgIHBhdGNoZXNSZWYuY3VycmVudC5pbnZlcnNlUGF0Y2hlcyxcbiAgICAgICAgXVxuICAgICAgOiBbc3RhdGUsIHVwZGF0ZVN0YXRlXVxuICApIGFzIFJlc3VsdDxJbml0aWFsVmFsdWU8Uz4sIE8sIEY+O1xufVxuXG50eXBlIFJlZHVjZXJSZXN1bHQ8XG4gIFMsXG4gIEEsXG4gIE8gZXh0ZW5kcyBQYXRjaGVzT3B0aW9ucyxcbiAgRiBleHRlbmRzIGJvb2xlYW4sXG4+ID0gTyBleHRlbmRzIHRydWUgfCBvYmplY3RcbiAgPyBbRiBleHRlbmRzIHRydWUgPyBJbW11dGFibGU8Uz4gOiBTLCBEaXNwYXRjaDxBPiwgUGF0Y2hlczxPPiwgUGF0Y2hlczxPPl1cbiAgOiBGIGV4dGVuZHMgdHJ1ZVxuICAgID8gW0ltbXV0YWJsZTxTPiwgRGlzcGF0Y2g8QT5dXG4gICAgOiBbUywgRGlzcGF0Y2g8QT5dO1xuXG50eXBlIFJlZHVjZXI8UywgQT4gPSAoZHJhZnRTdGF0ZTogRHJhZnQ8Uz4sIGFjdGlvbjogQSkgPT4gdm9pZCB8IFMgfCB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIHVzZU11dGF0aXZlUmVkdWNlcjxcbiAgUyxcbiAgQSxcbiAgSSxcbiAgRiBleHRlbmRzIGJvb2xlYW4gPSBmYWxzZSxcbiAgTyBleHRlbmRzIFBhdGNoZXNPcHRpb25zID0gZmFsc2UsXG4+KFxuICByZWR1Y2VyOiBSZWR1Y2VyPFMsIEE+LFxuICBpbml0aWFsaXplckFyZzogUyAmIEksXG4gIGluaXRpYWxpemVyOiAoYXJnOiBTICYgSSkgPT4gUyxcbiAgb3B0aW9ucz86IE9wdGlvbnM8TywgRj5cbik6IFJlZHVjZXJSZXN1bHQ8UywgQSwgTywgRj47XG5cbmZ1bmN0aW9uIHVzZU11dGF0aXZlUmVkdWNlcjxcbiAgUyxcbiAgQSxcbiAgSSxcbiAgRiBleHRlbmRzIGJvb2xlYW4gPSBmYWxzZSxcbiAgTyBleHRlbmRzIFBhdGNoZXNPcHRpb25zID0gZmFsc2UsXG4+KFxuICByZWR1Y2VyOiBSZWR1Y2VyPFMsIEE+LFxuICBpbml0aWFsaXplckFyZzogSSxcbiAgaW5pdGlhbGl6ZXI6IChhcmc6IEkpID0+IFMsXG4gIG9wdGlvbnM/OiBPcHRpb25zPE8sIEY+XG4pOiBSZWR1Y2VyUmVzdWx0PFMsIEEsIE8sIEY+O1xuXG5mdW5jdGlvbiB1c2VNdXRhdGl2ZVJlZHVjZXI8XG4gIFMsXG4gIEEsXG4gIEYgZXh0ZW5kcyBib29sZWFuID0gZmFsc2UsXG4gIE8gZXh0ZW5kcyBQYXRjaGVzT3B0aW9ucyA9IGZhbHNlLFxuPihcbiAgcmVkdWNlcjogUmVkdWNlcjxTLCBBPixcbiAgaW5pdGlhbFN0YXRlOiBTLFxuICBpbml0aWFsaXplcj86IHVuZGVmaW5lZCxcbiAgb3B0aW9ucz86IE9wdGlvbnM8TywgRj5cbik6IFJlZHVjZXJSZXN1bHQ8UywgQSwgTywgRj47XG5cbi8qKlxuICogYHVzZU11dGF0aXZlUmVkdWNlcmAgaXMgYSBob29rIHRoYXQgaXMgc2ltaWxhciB0byBgdXNlUmVkdWNlcmAgYnV0IGl0IHVzZXMgYG11dGF0aXZlYCB0byBoYW5kbGUgdGhlIHN0YXRlIHVwZGF0ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgYWN0LCByZW5kZXJIb29rIH0gZnJvbSAnQHRlc3RpbmctbGlicmFyeS9yZWFjdCc7XG4gKiBpbXBvcnQgeyB0eXBlIERyYWZ0IH0gZnJvbSAnbXV0YXRpdmUnO1xuICpcbiAqIGltcG9ydCB7IHVzZU11dGF0aXZlUmVkdWNlciB9IGZyb20gJy4uL3NyYy9pbmRleCc7XG4gKlxuICogY29uc3QgeyByZXN1bHQgfSA9IHJlbmRlckhvb2soKCkgPT5cbiAqICAgdXNlTXV0YXRpdmVSZWR1Y2VyKFxuICogICAgIChcbiAqICAgICAgIGRyYWZ0OiBEcmFmdDxSZWFkb25seTx7IGNvdW50OiBudW1iZXIgfT4+LFxuICogICAgICAgYWN0aW9uOiB7XG4gKiAgICAgICAgIHR5cGU6ICdpbmNyZW1lbnQnO1xuICogICAgICAgfVxuICogICAgICkgPT4ge1xuICogICAgICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICogICAgICAgICBjYXNlICdpbmNyZW1lbnQnOlxuICogICAgICAgICAgIGRyYWZ0LmNvdW50ICs9IDE7XG4gKiAgICAgICB9XG4gKiAgICAgfSxcbiAqICAgICB7IGNvdW50OiAwIH1cbiAqICAgKVxuICogKTtcbiAqIGNvbnN0IFssIGRpc3BhdGNoXSA9IHJlc3VsdC5jdXJyZW50O1xuICogYWN0KCgpID0+IGRpc3BhdGNoKHsgdHlwZTogJ2luY3JlbWVudCcgfSkpO1xuICogZXhwZWN0KHJlc3VsdC5jdXJyZW50WzBdKS50b0VxdWFsKHsgY291bnQ6IDEgfSk7XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlTXV0YXRpdmVSZWR1Y2VyPFxuICBTLFxuICBBLFxuICBJLFxuICBGIGV4dGVuZHMgYm9vbGVhbiA9IGZhbHNlLFxuICBPIGV4dGVuZHMgUGF0Y2hlc09wdGlvbnMgPSBmYWxzZSxcbj4oXG4gIC8qKlxuICAgKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSB0cmVlLCBnaXZlbiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgYWN0aW9uIHRvIGhhbmRsZS5cbiAgICovXG4gIHJlZHVjZXI6IFJlZHVjZXI8UywgQT4sXG4gIC8qKlxuICAgKiBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHByb3ZpZGUgYW4gaW5pdGlhbGl6ZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIHRoZSBpbml0aWFsIHN0YXRlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZXJBcmc6IFMgJiBJLFxuICAvKipcbiAgICogQW4gaW5pdGlhbGl6ZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBpbml0aWFsIHN0YXRlLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGBpbml0aWFsaXplckFyZ2AuXG4gICAqL1xuICBpbml0aWFsaXplcj86IChhcmc6IFMgJiBJKSA9PiBTLFxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgdGhlIGB1c2VNdXRhdGl2ZVJlZHVjZXJgIGhvb2suXG4gICAqL1xuICBvcHRpb25zPzogT3B0aW9uczxPLCBGPlxuKTogUmVkdWNlclJlc3VsdDxTLCBBLCBPLCBGPiB7XG4gIGNvbnN0IHBhdGNoZXNSZWYgPSB1c2VSZWY8e1xuICAgIHBhdGNoZXM6IFBhdGNoZXM7XG4gICAgaW52ZXJzZVBhdGNoZXM6IFBhdGNoZXM7XG4gIH0+KHtcbiAgICBwYXRjaGVzOiBbXSxcbiAgICBpbnZlcnNlUGF0Y2hlczogW10sXG4gIH0pO1xuICAvLyNyZWdpb24gc3VwcG9ydCBzdHJpY3QgbW9kZSBhbmQgY29uY3VycmVudCBmZWF0dXJlc1xuICBjb25zdCBjb3VudCA9IHVzZVJlZigwKTtcbiAgY29uc3QgcmVuZGVyQ291bnQgPSB1c2VSZWYoMCk7XG4gIGxldCBjdXJyZW50Q291bnQgPSBjb3VudC5jdXJyZW50O1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvdW50LmN1cnJlbnQgPSBjdXJyZW50Q291bnQ7XG4gICAgcmVuZGVyQ291bnQuY3VycmVudCA9IGN1cnJlbnRDb3VudDtcbiAgfSk7XG4gIGN1cnJlbnRDb3VudCArPSAxO1xuICByZW5kZXJDb3VudC5jdXJyZW50ICs9IDE7XG4gIC8vI2VuZHJlZ2lvblxuICBjb25zdCBjYWNoZWRSZWR1Y2VyOiBhbnkgPSB1c2VNZW1vKFxuICAgICgpID0+IChzdGF0ZTogYW55LCBhY3Rpb246IGFueSkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0OiBhbnkgPSBjcmVhdGUoXG4gICAgICAgIHN0YXRlLFxuICAgICAgICAoZHJhZnQpID0+IHJlZHVjZXIoZHJhZnQsIGFjdGlvbiksXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgICBpZiAob3B0aW9ucz8uZW5hYmxlUGF0Y2hlcykge1xuICAgICAgICAvLyBjaGVjayByZW5kZXIgY291bnQsIHN1cHBvcnQgc3RyaWN0IG1vZGUgYW5kIGNvbmN1cnJlbnQgZmVhdHVyZXNcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHJlbmRlckNvdW50LmN1cnJlbnQgPT09IGNvdW50LmN1cnJlbnQgfHxcbiAgICAgICAgICByZW5kZXJDb3VudC5jdXJyZW50ID09PSBjb3VudC5jdXJyZW50ICsgMVxuICAgICAgICApIHtcbiAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShwYXRjaGVzUmVmLmN1cnJlbnQucGF0Y2hlcywgcmVzdWx0WzFdKTtcbiAgICAgICAgICAvLyBgaW52ZXJzZVBhdGNoZXNgIHNob3VsZCBiZSBpbiByZXZlcnNlIG9yZGVyIHdoZW4gbXVsdGlwbGUgc2V0U3RhdGUoKSBleGVjdXRpb25zXG4gICAgICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoXG4gICAgICAgICAgICBwYXRjaGVzUmVmLmN1cnJlbnQuaW52ZXJzZVBhdGNoZXMsXG4gICAgICAgICAgICByZXN1bHRbMl1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgW3JlZHVjZXJdXG4gICk7XG4gIGNvbnN0IHJlc3VsdDogYW55ID0gdXNlUmVkdWNlcihcbiAgICBjYWNoZWRSZWR1Y2VyLFxuICAgIGluaXRpYWxpemVyQXJnIGFzIGFueSxcbiAgICBpbml0aWFsaXplciBhcyBhbnlcbiAgKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAob3B0aW9ucz8uZW5hYmxlUGF0Y2hlcykge1xuICAgICAgLy8gUmVzZXQgYHBhdGNoZXNSZWZgIHdoZW4gdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZCBlYWNoIHRpbWVcbiAgICAgIHBhdGNoZXNSZWYuY3VycmVudC5wYXRjaGVzID0gW107XG4gICAgICBwYXRjaGVzUmVmLmN1cnJlbnQuaW52ZXJzZVBhdGNoZXMgPSBbXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3B0aW9ucz8uZW5hYmxlUGF0Y2hlc1xuICAgID8gW1xuICAgICAgICByZXN1bHRbMF0sXG4gICAgICAgIHJlc3VsdFsxXSxcbiAgICAgICAgcGF0Y2hlc1JlZi5jdXJyZW50LnBhdGNoZXMsXG4gICAgICAgIHBhdGNoZXNSZWYuY3VycmVudC5pbnZlcnNlUGF0Y2hlcyxcbiAgICAgIF0gYXMgUmVkdWNlclJlc3VsdDxTLCBBLCBPLCBGPlxuICAgIDogcmVzdWx0O1xufVxuXG5leHBvcnQge1xuICB0eXBlIERyYWZ0RnVuY3Rpb24sXG4gIHR5cGUgVXBkYXRlcixcbiAgdHlwZSBSZWR1Y2VyLFxuICB1c2VNdXRhdGl2ZSxcbiAgdXNlTXV0YXRpdmVSZWR1Y2VyLFxufTtcbiJdfQ=="],
  "mappings": "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",
  "names": ["index", "set", "generatePatches", "current", "value", "proxyDraft", "ensureShallowCopy", "create", "base", "draft", "mark", "result", "useMutative", "initialValue", "options", "patchesRef", "useRef", "patches", "inversePatches", "count", "renderCount", "currentCount", "current", "useEffect", "state", "setState", "useState", "updateState", "useCallback", "updater", "latest", "result", "create", "enablePatches", "Array", "prototype", "push", "apply", "unshift", "useMutativeReducer", "reducer", "initializerArg", "initializer", "cachedReducer", "useMemo", "action", "draft", "useReducer"]
}
